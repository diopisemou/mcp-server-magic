
import { ServerConfig, GenerationResult, ServerFile } from '@/types';

/**
 * Generate MCP server code based on the provided server configuration
 * @param config Server configuration including endpoints, language, and authentication settings
 * @returns GenerationResult object with success status and generated files or error
 */
export const generateServer = async (config: ServerConfig): Promise<GenerationResult> => {
  try {
    // In a real implementation, this would call a Supabase edge function
    // For now, we'll simulate the generation with a timeout
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Generate server files based on configuration
    const files = generateServerFiles(config);
    
    return {
      success: true,
      serverUrl: `https://mcp-${config.name.toLowerCase().replace(/\s+/g, '-')}.supabase.co`,
      files
    };
  } catch (error) {
    console.error('Server generation error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error during server generation'
    };
  }
};

/**
 * Generate server files based on server configuration
 * @param config Server configuration 
 * @returns Array of ServerFile objects
 */
const generateServerFiles = (config: ServerConfig): ServerFile[] => {
  const files: ServerFile[] = [];
  
  if (config.language === 'Python') {
    // Generate Python MCP server files
    files.push(
      {
        name: 'main.py',
        path: '/',
        content: generatePythonMainFile(config),
        type: 'code'
      },
      {
        name: 'requirements.txt',
        path: '/',
        content: 'anthropic-sdk==0.9.0\nfastapi==0.110.0\nuvicorn==0.27.0\npydantic==2.6.0\npython-dotenv==1.0.0\nrequests==2.31.0\n',
        type: 'config'
      },
      {
        name: 'Dockerfile',
        path: '/',
        content: generateDockerfile(config),
        type: 'config'
      },
      {
        name: 'README.md',
        path: '/',
        content: generateReadme(config),
        type: 'documentation'
      }
    );
    
    // Add endpoint files
    if (config.endpoints.length > 0) {
      files.push({
        name: 'endpoints.py',
        path: '/api/',
        content: generatePythonEndpointsFile(config),
        type: 'code'
      });
    }
  } else {
    // Generate TypeScript MCP server files
    files.push(
      {
        name: 'index.ts',
        path: '/src/',
        content: generateTypeScriptMainFile(config),
        type: 'code'
      },
      {
        name: 'package.json',
        path: '/',
        content: generatePackageJson(config),
        type: 'config'
      },
      {
        name: 'tsconfig.json',
        path: '/',
        content: '{\n  "compilerOptions": {\n    "target": "ES2020",\n    "module": "NodeNext",\n    "moduleResolution": "NodeNext",\n    "esModuleInterop": true,\n    "strict": true,\n    "outDir": "dist"\n  }\n}',
        type: 'config'
      },
      {
        name: 'Dockerfile',
        path: '/',
        content: generateDockerfile(config),
        type: 'config'
      },
      {
        name: 'README.md',
        path: '/',
        content: generateReadme(config),
        type: 'documentation'
      }
    );
    
    // Add endpoint files
    if (config.endpoints.length > 0) {
      files.push({
        name: 'endpoints.ts',
        path: '/src/',
        content: generateTypeScriptEndpointsFile(config),
        type: 'code'
      });
    }
  }
  
  return files;
};

/**
 * Generate Python main file
 */
const generatePythonMainFile = (config: ServerConfig): string => {
  const authCode = generatePythonAuthCode(config);
  
  return `"""
MCP Server for ${config.name}
${config.description}

Generated by MCP Server Generator
"""

import os
from fastapi import FastAPI, Depends, HTTPException, Header
from anthropic import Anthropic
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv

# Import endpoint handlers
from api.endpoints import get_resources, execute_tools

# Load environment variables
load_dotenv()

# Initialize FastAPI app
app = FastAPI(
    title="${config.name} MCP Server",
    description="${config.description}",
    version="1.0.0"
)

${authCode}

# MCP schema definitions
class MCPRequest(BaseModel):
    resource_name: Optional[str] = None
    tool_name: Optional[str] = None
    tool_params: Optional[Dict[str, Any]] = None

class MCPResponse(BaseModel):
    content: Any
    metadata: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

@app.get("/")
async def root():
    return {"message": "Welcome to ${config.name} MCP Server"}

@app.get("/mcp/resources")
async def resources(${config.authentication.type !== 'None' ? 'authenticated: bool = Depends(verify_auth),' : ''} anthropic_version: Optional[str] = Header(None)):
    """Return available MCP resources"""
    try:
        available_resources = get_resources()
        return available_resources
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/mcp/resource/{resource_name}")
async def get_resource(
    resource_name: str, 
    ${config.authentication.type !== 'None' ? 'authenticated: bool = Depends(verify_auth),' : ''}
    anthropic_version: Optional[str] = Header(None)
):
    """Get data from a specific MCP resource"""
    try:
        response = execute_tools("resource", resource_name, {})
        return MCPResponse(content=response)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/mcp/tool/{tool_name}")
async def execute_tool(
    tool_name: str, 
    request: Dict[str, Any],
    ${config.authentication.type !== 'None' ? 'authenticated: bool = Depends(verify_auth),' : ''}
    anthropic_version: Optional[str] = Header(None)
):
    """Execute a specific MCP tool"""
    try:
        response = execute_tools("tool", tool_name, request)
        return MCPResponse(content=response)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
`;
};

/**
 * Generate Python endpoints file
 */
const generatePythonEndpointsFile = (config: ServerConfig): string => {
  const resourceEndpoints = config.endpoints
    .filter(e => e.mcpType === 'resource')
    .map(e => `"${e.path.replace(/\/+/g, '_').replace(/[{}]/g, '')}"`)
    .join(', ');
  
  const toolEndpoints = config.endpoints
    .filter(e => e.mcpType === 'tool')
    .map(e => `"${e.path.replace(/\/+/g, '_').replace(/[{}]/g, '')}"`)
    .join(', ');
  
  let code = `"""
API Endpoint handlers for ${config.name} MCP Server

Generated by MCP Server Generator
"""

import requests
from typing import Dict, Any, List, Union, Optional

# Base API URL
BASE_URL = "https://api.example.com"  # Replace with your actual API base URL

# Authentication setup
${config.authentication.type !== 'None' ? generatePythonAuthSetup(config) : '# No authentication required'}

def get_resources() -> Dict[str, List[str]]:
    """Return all available MCP resources"""
    return {
        "resources": [${resourceEndpoints}],
        "tools": [${toolEndpoints}]
    }

def execute_tools(type_name: str, name: str, params: Dict[str, Any]) -> Any:
    """Execute a resource request or tool operation"""
    if type_name == "resource":
        return get_resource(name, params)
    elif type_name == "tool":
        return execute_tool(name, params)
    else:
        raise ValueError(f"Unknown type: {type_name}")

def get_resource(name: str, params: Dict[str, Any]) -> Any:
    """Handle resource requests"""
    # Map resource name to handler
`;

  // Add resource handlers
  config.endpoints
    .filter(e => e.mcpType === 'resource')
    .forEach(endpoint => {
      const handlerName = endpoint.path.replace(/\/+/g, '_').replace(/[{}]/g, '');
      code += `    if name == "${handlerName}":
        return handle_${handlerName}(params)
`;
    });

  code += `    raise ValueError(f"Unknown resource: {name}")

def execute_tool(name: str, params: Dict[str, Any]) -> Any:
    """Handle tool executions"""
    # Map tool name to handler
`;

  // Add tool handlers
  config.endpoints
    .filter(e => e.mcpType === 'tool')
    .forEach(endpoint => {
      const handlerName = endpoint.path.replace(/\/+/g, '_').replace(/[{}]/g, '');
      code += `    if name == "${handlerName}":
        return handle_${handlerName}(params)
`;
    });

  code += `    raise ValueError(f"Unknown tool: {name}")

`;

  // Generate handler functions for each endpoint
  config.endpoints.forEach(endpoint => {
    const handlerName = endpoint.path.replace(/\/+/g, '_').replace(/[{}]/g, '');
    const methodName = endpoint.method.toLowerCase();
    const paramsList = endpoint.parameters
      .map(p => `${p.name}${p.required ? '' : '=None'}`)
      .join(', ');
    
    code += `def handle_${handlerName}(params: Dict[str, Any]) -> Any:
    """
    ${endpoint.description}
    
    Endpoint: ${endpoint.method} ${endpoint.path}
    """
    url = f"{BASE_URL}${endpoint.path.replace(/{([^}]+)}/g, '{params.get("$1", "")}')}";
    
    try:
        ${methodName === 'get' ? 
          `response = requests.get(url, headers=get_headers())` : 
          `response = requests.${methodName}(url, json=params, headers=get_headers())`
        }
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": f"API request failed: {str(e)}"}

`;
  });

  return code;
};

/**
 * Generate Python authentication code
 */
const generatePythonAuthCode = (config: ServerConfig): string => {
  if (config.authentication.type === 'None') {
    return '# No authentication required';
  }
  
  if (config.authentication.type === 'ApiKey') {
    return `# API Key authentication
def verify_auth(
    ${config.authentication.location === 'header' 
      ? `${config.authentication.name}: str = Header(None, alias="${config.authentication.name}")` 
      : `${config.authentication.name}: str = None`}
) -> bool:
    """Verify API key authentication"""
    expected_key = os.getenv("API_KEY")
    if not ${config.authentication.name} or ${config.authentication.name} != expected_key:
        raise HTTPException(
            status_code=401,
            detail="Invalid or missing API key"
        )
    return True`;
  }
  
  if (config.authentication.type === 'Bearer') {
    return `# Bearer token authentication
def verify_auth(authorization: str = Header(None)) -> bool:
    """Verify bearer token authentication"""
    expected_token = os.getenv("AUTH_TOKEN")
    if not authorization or not authorization.startswith("Bearer ") or authorization.replace("Bearer ", "") != expected_token:
        raise HTTPException(
            status_code=401,
            detail="Invalid or missing bearer token"
        )
    return True`;
  }
  
  if (config.authentication.type === 'Basic') {
    return `# Basic authentication
import base64

def verify_auth(authorization: str = Header(None)) -> bool:
    """Verify basic authentication"""
    if not authorization or not authorization.startswith("Basic "):
        raise HTTPException(
            status_code=401,
            detail="Invalid or missing basic auth"
        )
    
    try:
        credentials = base64.b64decode(authorization.replace("Basic ", "")).decode("utf-8")
        username, password = credentials.split(":")
        
        expected_username = os.getenv("AUTH_USERNAME")
        expected_password = os.getenv("AUTH_PASSWORD")
        
        if username != expected_username or password != expected_password:
            raise HTTPException(
                status_code=401,
                detail="Invalid credentials"
            )
    except Exception:
        raise HTTPException(
            status_code=401,
            detail="Invalid basic auth format"
        )
    
    return True`;
  }
  
  return '# Authentication configuration error';
};

/**
 * Generate Python authentication setup
 */
const generatePythonAuthSetup = (config: ServerConfig): string => {
  if (config.authentication.type === 'ApiKey') {
    return `# API Key authentication setup
def get_headers():
    return {
        "${config.authentication.name}": "YOUR_API_KEY_HERE"  # Replace with actual key or environment variable
    }`;
  }
  
  if (config.authentication.type === 'Bearer') {
    return `# Bearer token authentication setup
def get_headers():
    return {
        "Authorization": "Bearer YOUR_TOKEN_HERE"  # Replace with actual token or environment variable
    }`;
  }
  
  if (config.authentication.type === 'Basic') {
    return `# Basic authentication setup
import base64

def get_headers():
    credentials = "username:password"  # Replace with actual credentials
    encoded_credentials = base64.b64encode(credentials.encode()).decode()
    return {
        "Authorization": f"Basic {encoded_credentials}"
    }`;
  }
  
  return '# No authentication setup required';
};

/**
 * Generate TypeScript main file
 */
const generateTypeScriptMainFile = (config: ServerConfig): string => {
  return `/**
 * MCP Server for ${config.name}
 * ${config.description}
 * 
 * Generated by MCP Server Generator
 */

import express from 'express';
import cors from 'cors';
import { config as dotenvConfig } from 'dotenv';
import { getResources, executeTools } from './endpoints';

// Load environment variables
dotenvConfig();

const app = express();
app.use(cors());
app.use(express.json());

// Authentication middleware
${generateTypeScriptAuthMiddleware(config)}

app.get('/', (req, res) => {
  res.json({ message: 'Welcome to ${config.name} MCP Server' });
});

app.get('/mcp/resources', ${config.authentication.type !== 'None' ? 'authenticateRequest, ' : ''}(req, res) => {
  try {
    const resources = getResources();
    res.json(resources);
  } catch (error) {
    console.error('Error fetching resources:', error);
    res.status(500).json({ error: 'Failed to fetch resources' });
  }
});

app.get('/mcp/resource/:resourceName', ${config.authentication.type !== 'None' ? 'authenticateRequest, ' : ''}(req, res) => {
  try {
    const { resourceName } = req.params;
    const result = executeTools('resource', resourceName, {});
    res.json({ content: result });
  } catch (error) {
    console.error(\`Error executing resource \${req.params.resourceName}:\`, error);
    res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
  }
});

app.post('/mcp/tool/:toolName', ${config.authentication.type !== 'None' ? 'authenticateRequest, ' : ''}(req, res) => {
  try {
    const { toolName } = req.params;
    const params = req.body;
    const result = executeTools('tool', toolName, params);
    res.json({ content: result });
  } catch (error) {
    console.error(\`Error executing tool \${req.params.toolName}:\`, error);
    res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(\`${config.name} MCP Server running on port \${PORT}\`);
});
`;
};

/**
 * Generate TypeScript endpoints file
 */
const generateTypeScriptEndpointsFile = (config: ServerConfig): string => {
  const resourceEndpoints = config.endpoints
    .filter(e => e.mcpType === 'resource')
    .map(e => `"${e.path.replace(/\/+/g, '_').replace(/[{}]/g, '')}"`)
    .join(', ');
  
  const toolEndpoints = config.endpoints
    .filter(e => e.mcpType === 'tool')
    .map(e => `"${e.path.replace(/\/+/g, '_').replace(/[{}]/g, '')}"`)
    .join(', ');
  
  let code = `/**
 * API Endpoint handlers for ${config.name} MCP Server
 * 
 * Generated by MCP Server Generator
 */

import axios from 'axios';

// Base API URL
const BASE_URL = 'https://api.example.com'; // Replace with your actual API base URL

// Authentication setup
${generateTypeScriptAuthSetup(config)}

/**
 * Return all available MCP resources
 */
export function getResources() {
  return {
    resources: [${resourceEndpoints}],
    tools: [${toolEndpoints}]
  };
}

/**
 * Execute a resource request or tool operation
 */
export function executeTools(typeName: 'resource' | 'tool', name: string, params: Record<string, any>) {
  if (typeName === 'resource') {
    return getResource(name, params);
  } else if (typeName === 'tool') {
    return executeTool(name, params);
  } else {
    throw new Error(\`Unknown type: \${typeName}\`);
  }
}

/**
 * Handle resource requests
 */
function getResource(name: string, params: Record<string, any>) {
  // Map resource name to handler
`;

  // Add resource handlers
  config.endpoints
    .filter(e => e.mcpType === 'resource')
    .forEach(endpoint => {
      const handlerName = endpoint.path.replace(/\/+/g, '_').replace(/[{}]/g, '');
      code += `  if (name === '${handlerName}') {
    return handle${capitalizeFirstLetter(handlerName)}(params);
  }
`;
    });

  code += `  throw new Error(\`Unknown resource: \${name}\`);
}

/**
 * Handle tool executions
 */
function executeTool(name: string, params: Record<string, any>) {
  // Map tool name to handler
`;

  // Add tool handlers
  config.endpoints
    .filter(e => e.mcpType === 'tool')
    .forEach(endpoint => {
      const handlerName = endpoint.path.replace(/\/+/g, '_').replace(/[{}]/g, '');
      code += `  if (name === '${handlerName}') {
    return handle${capitalizeFirstLetter(handlerName)}(params);
  }
`;
    });

  code += `  throw new Error(\`Unknown tool: \${name}\`);
}

`;

  // Generate handler functions for each endpoint
  config.endpoints.forEach(endpoint => {
    const handlerName = capitalizeFirstLetter(endpoint.path.replace(/\/+/g, '_').replace(/[{}]/g, ''));
    const methodName = endpoint.method.toLowerCase();
    
    code += `/**
 * ${endpoint.description}
 * 
 * Endpoint: ${endpoint.method} ${endpoint.path}
 */
function handle${handlerName}(params: Record<string, any>) {
  try {
    const url = \`\${BASE_URL}${endpoint.path.replace(/{([^}]+)}/g, '${params.$1 || ""}')}\`;
    
    ${methodName === 'get' 
      ? 'return axios.get(url, { headers: getHeaders() }).then(response => response.data);' 
      : `return axios.${methodName}(url, params, { headers: getHeaders() }).then(response => response.data);`
    }
  } catch (error) {
    console.error(\`API request failed: \${error}\`);
    return { error: 'API request failed' };
  }
}

`;
  });

  return code;
};

/**
 * Generate TypeScript authentication middleware
 */
const generateTypeScriptAuthMiddleware = (config: ServerConfig): string => {
  if (config.authentication.type === 'None') {
    return '// No authentication required';
  }
  
  if (config.authentication.type === 'ApiKey') {
    return `// API Key authentication middleware
const authenticateRequest = (req, res, next) => {
  const apiKey = ${config.authentication.location === 'header' 
    ? `req.headers['${config.authentication.name.toLowerCase()}']` 
    : `req.query.${config.authentication.name}`};
  
  const expectedKey = process.env.API_KEY;
  
  if (!apiKey || apiKey !== expectedKey) {
    return res.status(401).json({ error: 'Invalid or missing API key' });
  }
  
  next();
};`;
  }
  
  if (config.authentication.type === 'Bearer') {
    return `// Bearer token authentication middleware
const authenticateRequest = (req, res, next) => {
  const authHeader = req.headers.authorization;
  const expectedToken = process.env.AUTH_TOKEN;
  
  if (!authHeader || !authHeader.startsWith('Bearer ') || authHeader.replace('Bearer ', '') !== expectedToken) {
    return res.status(401).json({ error: 'Invalid or missing bearer token' });
  }
  
  next();
};`;
  }
  
  if (config.authentication.type === 'Basic') {
    return `// Basic authentication middleware
const authenticateRequest = (req, res, next) => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Basic ')) {
    return res.status(401).json({ error: 'Invalid or missing basic auth' });
  }
  
  try {
    const credentials = Buffer.from(authHeader.replace('Basic ', ''), 'base64').toString('utf-8');
    const [username, password] = credentials.split(':');
    
    const expectedUsername = process.env.AUTH_USERNAME;
    const expectedPassword = process.env.AUTH_PASSWORD;
    
    if (username !== expectedUsername || password !== expectedPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid basic auth format' });
  }
};`;
  }
  
  return '// Authentication configuration error';
};

/**
 * Generate TypeScript authentication setup
 */
const generateTypeScriptAuthSetup = (config: ServerConfig): string => {
  if (config.authentication.type === 'None') {
    return `// No authentication required
function getHeaders() {
  return {};
}`;
  }
  
  if (config.authentication.type === 'ApiKey') {
    return `// API Key authentication setup
function getHeaders() {
  return {
    '${config.authentication.name}': 'YOUR_API_KEY_HERE' // Replace with actual key or environment variable
  };
}`;
  }
  
  if (config.authentication.type === 'Bearer') {
    return `// Bearer token authentication setup
function getHeaders() {
  return {
    'Authorization': 'Bearer YOUR_TOKEN_HERE' // Replace with actual token or environment variable
  };
}`;
  }
  
  if (config.authentication.type === 'Basic') {
    return `// Basic authentication setup
function getHeaders() {
  const credentials = 'username:password'; // Replace with actual credentials
  const encodedCredentials = Buffer.from(credentials).toString('base64');
  return {
    'Authorization': \`Basic \${encodedCredentials}\`
  };
}`;
  }
  
  return '// No authentication setup required';
};

/**
 * Generate package.json for TypeScript projects
 */
const generatePackageJson = (config: ServerConfig): string => {
  return `{
  "name": "${config.name.toLowerCase().replace(/\\s+/g, '-')}-mcp-server",
  "version": "1.0.0",
  "description": "${config.description}",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn src/index.ts"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.16.0",
    "axios": "^1.6.7",
    "cors": "^2.8.5",
    "dotenv": "^16.4.0",
    "express": "^4.18.2"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.5",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  }
}`;
};

/**
 * Generate Dockerfile
 */
const generateDockerfile = (config: ServerConfig): string => {
  if (config.language === 'Python') {
    return `FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]`;
  } else {
    return `FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["node", "dist/index.js"]`;
  }
};

/**
 * Generate README.md
 */
const generateReadme = (config: ServerConfig): string => {
  return `# ${config.name} MCP Server

${config.description}

## Overview

This is a Model Context Protocol (MCP) server that provides a standardized way for AI models like Claude to interact with the ${config.name} API. The server exposes endpoints that can be called by MCP hosts to retrieve data or perform actions.

## Getting Started

### Prerequisites

${config.language === 'Python' ? 
  '- Python 3.8+\n- pip' : 
  '- Node.js 18+\n- npm or yarn'}

### Installation

1. Clone this repository
2. Install dependencies:
   ${config.language === 'Python' ? 
     '```\npip install -r requirements.txt\n```' : 
     '```\nnpm install\n```'}

${config.authentication.type !== 'None' ? `
### Environment Variables

Create a \`.env\` file in the root directory and add the following variables:

${config.authentication.type === 'ApiKey' ? 
  '```\nAPI_KEY=your_api_key_here\n```' : 
  config.authentication.type === 'Bearer' ? 
  '```\nAUTH_TOKEN=your_token_here\n```' : 
  '```\nAUTH_USERNAME=your_username_here\nAUTH_PASSWORD=your_password_here\n```'}
` : ''}

### Running the Server

${config.language === 'Python' ? 
  '```\nuvicorn main:app --reload\n```\n\nThe server will be available at http://localhost:8000' : 
  '```\nnpm run dev\n```\n\nThe server will be available at http://localhost:3000'}

## Available Endpoints

The server exposes the following MCP endpoints:

- \`GET /mcp/resources\`: Lists all available resources and tools
- \`GET /mcp/resource/{resource_name}\`: Retrieves data from a specific resource
- \`POST /mcp/tool/{tool_name}\`: Executes a specific tool

## Docker Deployment

This server can be deployed using Docker:

\`\`\`
docker build -t ${config.name.toLowerCase().replace(/\\s+/g, '-')}-mcp-server .
docker run -p ${config.language === 'Python' ? '8000:8000' : '3000:3000'} ${config.name.toLowerCase().replace(/\\s+/g, '-')}-mcp-server
\`\`\`

## Generated by MCP Server Generator
`;
};

/**
 * Helper function to capitalize first letter
 */
function capitalizeFirstLetter(string: string): string {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
