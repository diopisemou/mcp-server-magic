import { ServerConfig, ServerFile, GenerationResult } from '@/types';

// Extended interface for proxy-specific properties
interface ExtendedServerConfig extends ServerConfig {
  mode?: 'direct' | 'proxy';
  targetBaseUrl?: string;
  cacheEnabled?: boolean;
  rateLimitingEnabled?: boolean;
}

/**
 * Generate TypeScript/Node.js proxy server files based on the given configuration
 * This creates an MCP server that proxies requests to an existing API using the official MCP SDK
 */
export const generateNodeProxyServer = (config: ExtendedServerConfig): GenerationResult => {
  const serverFiles: ServerFile[] = [];
  const { authentication, targetBaseUrl } = config;

  // Generate package.json
  serverFiles.push({
    name: 'package.json',
    path: '/',
    content: JSON.stringify(
      {
        name: config.name.toLowerCase().replace(/\s+/g, '-'),
        version: '1.0.0',
        description: config.description || 'MCP Proxy Server generated by MCP Server Generator',
        main: 'dist/index.js',
        type: 'module', // Use ES modules for MCP SDK compatibility
        scripts: {
          start: 'node dist/index.js',
          build: 'tsc',
          dev: 'ts-node-esm src/index.ts'
        },
        dependencies: {
          '@modelcontextprotocol/sdk': '^0.1.0',
          'dotenv': '^16.3.1',
          'axios': '^1.6.0',
          'typescript': '^5.0.4',
          'ts-node': '^10.9.1',
          'node-cache': '^5.1.2'
        }
      },
      null,
      2
    ),
    type: 'config',
    language: 'json'
  });

  // Generate .env file
  serverFiles.push({
    name: '.env',
    path: '/',
    content: `# MCP Proxy Server Configuration
PORT=3000
TARGET_API_URL=${targetBaseUrl || 'https://api.example.com'}
${authentication.type !== 'None' ? `MCP_API_KEY=${config.authSecret || 'your-mcp-api-key'}` : ''}
${authentication.type !== 'None' ? `TARGET_API_KEY=your-target-api-key` : ''}
`,
    type: 'config',
    language: 'plaintext'
  });

  // Generate README.md
  serverFiles.push({
    name: 'README.md',
    path: '/',
    content: `# ${config.name}

This is a Model Context Protocol (MCP) proxy server generated by MCP Server Generator.

## Description

This server acts as a proxy between MCP clients (like Claude) and your existing API (${targetBaseUrl || 'your API'}). It translates MCP requests into API calls and converts the responses back to MCP format.

## Getting Started

1. Install dependencies:
   \`\`\`
   npm install
   \`\`\`

2. Configure the \`.env\` file with your target API details.

3. Build the project:
   \`\`\`
   npm run build
   \`\`\`

4. Start the server:
   \`\`\`
   npm start
   \`\`\`

## Available Endpoints

${config.endpoints.map(endpoint => `- \`${endpoint.method} ${endpoint.path}\`: ${endpoint.description}`).join('\n')}

## Authentication

${authentication.type === 'None' 
  ? 'This MCP server does not require authentication. However, you may need to configure authentication for the target API in the proxy settings.' 
  : `This MCP server uses ${authentication.type} authentication. Additionally, you can configure authentication for the target API in the .env file.`}

## Features

${config.cacheEnabled ? '- Response caching is enabled to improve performance.\n' : ''}${config.rateLimitingEnabled ? '- Rate limiting is configured to avoid overloading the target API.\n' : ''}
`,
    type: 'documentation',
    language: 'markdown'
  });

  // Generate tsconfig.json
  serverFiles.push({
    name: 'tsconfig.json',
    path: '/',
    content: JSON.stringify(
      {
        compilerOptions: {
          target: 'es2020',
          module: 'commonjs',
          strict: true,
          esModuleInterop: true,
          skipLibCheck: true,
          forceConsistentCasingInFileNames: true,
          outDir: 'dist'
        },
        include: ['src/**/*'],
        exclude: ['node_modules']
      },
      null,
      2
    ),
    type: 'config',
    language: 'json'
  });
  
  // Generate index.ts (main file) - Using MCP SDK
  serverFiles.push({
    name: 'index.ts',
    path: '/src/',
    content: `import dotenv from 'dotenv';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { HttpServerTransport } from '@modelcontextprotocol/sdk/server/http.js';
import {
  CallToolRequestSchema,
  ErrorCode,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ListToolsRequestSchema,
  McpError,
  ReadResourceRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
${config.cacheEnabled ? "import NodeCache from 'node-cache';" : ''}
import axios from 'axios';

dotenv.config();

// Check required environment variables
const TARGET_API_URL = process.env.TARGET_API_URL;
if (!TARGET_API_URL) {
  console.error('TARGET_API_URL not set in environment variables!');
  process.exit(1);
}

// Create proxy services
import { proxyService } from './services/proxyService.js';

/**
 * MCP Proxy Server Class
 */
class MCPProxyServer {
  private server: Server;
  private targetApiUrl: string;
  ${config.cacheEnabled ? 'private cache: NodeCache;' : ''}
  ${authentication.type !== 'None' ? 'private apiKey: string;' : ''}

  constructor() {
    // Initialize MCP server
    this.server = new Server(
      {
        name: '${config.name}',
        version: '1.0.0',
      },
      {
        capabilities: {
          resources: {},
          tools: {},
        },
      }
    );

    // Initialize server properties
    this.targetApiUrl = TARGET_API_URL;
    ${config.cacheEnabled ? 'this.cache = new NodeCache({ stdTTL: 300, checkperiod: 60 });' : ''}
    ${authentication.type !== 'None' ? "this.apiKey = process.env.MCP_API_KEY || 'default-key';" : ''}

    // Set up request handlers
    this.setupResourceHandlers();
    this.setupToolHandlers();
    
    // Error handling
    this.server.onerror = (error) => console.error('[MCP Error]', error);
    process.on('SIGINT', async () => {
      await this.server.close();
      process.exit(0);
    });
  }

  /**
   * Set up resource request handlers
   */
  private setupResourceHandlers() {
    // List available resources
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
      resources: [
        ${config.endpoints
          .filter(e => e.mcpType === 'resource' && e.selected !== false)
          .map(e => `{
            uri: '${e.path}',
            name: '${e.description || e.path}',
            description: '${e.description || 'Resource endpoint'}'
          }`).join(',\n        ')}
      ],
    }));

    // Resource templates for dynamic parameters
    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => ({
      resourceTemplates: [
        ${config.endpoints
          .filter(e => e.mcpType === 'resource' && e.selected !== false && e.parameters.some(p => p.required))
          .map(e => {
            const params = e.parameters.filter(p => p.required).map(p => p.name);
            return params.length > 0 ? `{
            uriTemplate: '${e.path.replace(/{([^}]+)}/g, '{$1}')}',
            name: '${e.description || e.path}',
            description: 'Dynamic resource with parameters: ${params.join(', ')}'
          }` : '';
          }).filter(t => t !== '').join(',\n        ')}
      ],
    }));

    // Read specific resources
    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      ${authentication.type !== 'None' ? `
      // Check authentication if required
      if (!this.authenticate(request.headers)) {
        throw new McpError(ErrorCode.Unauthorized, 'Invalid API key');
      }
      ` : ''}

      try {
        // Extract resource ID and parameters from URL
        const resourceUri = request.params.uri;
        const parts = resourceUri.split('?');
        const path = parts[0];
        
        // Handle parameters if present
        let params = {};
        if (parts.length > 1) {
          const queryString = parts[1];
          params = Object.fromEntries(new URLSearchParams(queryString));
        }
        
        // Make the request to the target API
        const response = await proxyService.proxyRequest(
          path.replace(/^\\//, ''), // Remove leading slash if present
          'GET',
          params
        );
        
        // Return in MCP format
        return {
          contents: [
            {
              uri: resourceUri,
              mimeType: 'application/json',
              text: JSON.stringify(response, null, 2),
            },
          ],
        };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
        throw new McpError(ErrorCode.InternalError, \`Proxy error: \${errorMsg}\`);
      }
    });
  }

  /**
   * Set up tool request handlers
   */
  private setupToolHandlers() {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        ${config.endpoints
          .filter(e => e.mcpType === 'tool' && e.selected !== false)
          .map(e => {
            const paramProperties = e.parameters
              .filter(p => p.required)
              .map(p => `"${p.name}": { 
                "type": "${p.type === 'number' ? 'number' : p.type === 'boolean' ? 'boolean' : 'string'}",
                "description": "${p.description || p.name}" 
              }`);
              
            return `{
            name: '${e.path}',
            description: '${e.description || 'Tool endpoint'}',
            inputSchema: {
              type: 'object',
              properties: {
                ${paramProperties.join(',\n                ')}
              },
              required: [${e.parameters.filter(p => p.required).map(p => `'${p.name}'`).join(', ')}]
            }
          }`}).join(',\n        ')}
      ],
    }));

    // Handle tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      ${authentication.type !== 'None' ? `
      // Check authentication if required
      if (!this.authenticate(request.headers)) {
        throw new McpError(ErrorCode.Unauthorized, 'Invalid API key');
      }
      ` : ''}

      try {
        // Find the endpoint that matches the requested tool
        const toolName = request.params.name;
        const endpoint = ${JSON.stringify(config.endpoints.filter(e => e.mcpType === 'tool'))}.find(e => e.path === toolName);
        
        if (!endpoint) {
          throw new McpError(ErrorCode.MethodNotFound, \`Tool \${toolName} not found\`);
        }
        
        // Make the request to the target API
        const response = await proxyService.proxyRequest(
          toolName.replace(/^\\//, ''), // Remove leading slash if present
          endpoint.method,
          null,
          request.params.arguments
        );
        
        // Return in MCP format
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(response, null, 2),
            },
          ],
        };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
        throw new McpError(ErrorCode.InternalError, \`Proxy error: \${errorMsg}\`);
      }
    });
  }

  ${authentication.type !== 'None' ? `
  /**
   * Authenticate the request
   */
  private authenticate(headers: Record<string, string>): boolean {
    // Get the API key from headers
    const apiKey = headers['${authentication.name || 'x-api-key'}'];
    
    // Compare with stored API key
    return apiKey === this.apiKey;
  }
  ` : ''}

  /**
   * Start the MCP server
   */
  async run() {
    // Choose transport (HTTP for direct usage, stdio for LLM integration)
    const port = parseInt(process.env.PORT || '3000');
    const transport = process.env.USE_STDIO === 'true' 
      ? new StdioServerTransport() 
      : new HttpServerTransport({ port });
    
    await this.server.connect(transport);
    
    console.log('MCP Proxy Server running');
    console.log(\`Proxying requests to \${this.targetApiUrl}\`);
    
    if (transport instanceof HttpServerTransport) {
      console.log(\`Server available at http://localhost:\${port}\`);
    } else {
      console.log('Running in stdio mode for LLM integration');
    }
  }
}

// Create and run the server
const server = new MCPProxyServer();
server.run().catch(console.error);
`,
    type: 'code',
    language: 'typescript'
  });
  
  // Generate auth middleware if needed
  if (authentication.type !== 'None') {
    serverFiles.push({
      name: 'auth.ts',
      path: '/src/middleware/',
      content: `import { Request, Response, NextFunction } from 'express';

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
  const apiKey = ${authentication.location === 'header' 
    ? `req.headers['${authentication.name || 'x-api-key'}']` 
    : `req.query['${authentication.name || 'api_key'}']`};
  
  if (!apiKey || apiKey !== process.env.MCP_API_KEY) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  next();
};
`,
      type: 'code',
      language: 'typescript'
    });
  }

  // Generate proxy service
  serverFiles.push({
    name: 'proxyService.ts',
    path: '/src/services/',
    content: `import axios, { AxiosRequestConfig } from 'axios';
import { Request } from 'express';
${config.cacheEnabled ? "import NodeCache from 'node-cache';" : ''}

// Create axios instance for API requests
const apiClient = axios.create({
  baseURL: process.env.TARGET_API_URL,
  timeout: 10000,
});

${config.cacheEnabled ? `
// Cache setup (TTL: 5 minutes)
const cache = new NodeCache({ stdTTL: 300, checkperiod: 60 });
` : ''}

// Add authentication to target API if needed
apiClient.interceptors.request.use((config) => {
  // Example: Add API key to header
  const targetApiKey = process.env.TARGET_API_KEY;
  if (targetApiKey) {
    config.headers['X-API-Key'] = targetApiKey;
    // Alternatively, you might need:
    // config.headers['Authorization'] = \`Bearer \${targetApiKey}\`;
  }
  return config;
});

/**
 * Generate a cache key based on the request
 */
const generateCacheKey = (path: string, params: any): string => {
  return \`\${path}-\${JSON.stringify(params)}\`;
};

/**
 * Forward a request to the target API and process the response
 */
export const proxyRequest = async (
  path: string,
  method: string = 'GET',
  params: any = {},
  body: any = null
): Promise<any> => {
  try {
    const cacheKey = generateCacheKey(path, params);
    
    ${config.cacheEnabled ? `
    // Check cache for GET requests
    if (method === 'GET' && cache.has(cacheKey)) {
      console.log(\`Cache hit for \${path}\`);
      return cache.get(cacheKey);
    }
    ` : ''}

    // Set up request configuration
    const config: AxiosRequestConfig = {
      method,
      url: path,
      params: method === 'GET' ? params : undefined,
      data: method !== 'GET' ? body : undefined,
    };

    // Make the request to the target API
    const response = await apiClient(config);
    
    ${config.cacheEnabled ? `
    // Cache the response for GET requests
    if (method === 'GET') {
      cache.set(cacheKey, response.data);
    }
    ` : ''}

    return response.data;
  } catch (error: any) {
    console.error(\`Error proxying request to \${path}:\`, error.message);
    
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      throw new Error(\`Target API responded with status \${error.response.status}: \${
        error.response.data?.message || error.response.statusText
      }\`);
    } else if (error.request) {
      // The request was made but no response was received
      throw new Error('Target API did not respond');
    } else {
      // Something happened in setting up the request
      throw new Error(error.message);
    }
  }
};

/**
 * Convert a regular API response to MCP format
 */
export const convertToMcpResource = (data: any, resourceId: string): any => {
  return {
    success: true,
    data: {
      id: resourceId,
      content: [
        {
          type: 'text',
          text: JSON.stringify(data, null, 2)
        }
      ]
    }
  };
};

/**
 * Convert a regular API response to MCP tool response format
 */
export const convertToMcpToolResponse = (data: any, toolId: string): any => {
  return {
    success: true,
    result: {
      id: toolId,
      content: [
        {
          type: 'text',
          text: JSON.stringify(data, null, 2)
        }
      ]
    }
  };
};

${config.rateLimitingEnabled ? `
// Simple rate limiter
const requestCounts: Record<string, number> = {};
const requestTimestamps: Record<string, number[]> = {};
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute in milliseconds
const RATE_LIMIT_MAX_REQUESTS = 60; // 60 requests per minute

export const rateLimiter = (clientId: string = 'default'): boolean => {
  const now = Date.now();
  
  // Initialize or clean up old timestamps
  if (!requestTimestamps[clientId]) {
    requestTimestamps[clientId] = [];
  }
  
  // Remove timestamps outside the current window
  requestTimestamps[clientId] = requestTimestamps[clientId].filter(
    timestamp => timestamp > now - RATE_LIMIT_WINDOW
  );
  
  // Check rate limit
  if (requestTimestamps[clientId].length >= RATE_LIMIT_MAX_REQUESTS) {
    return false; // Rate limit exceeded
  }
  
  // Record this request
  requestTimestamps[clientId].push(now);
  return true; // Request allowed
};
` : ''}
`,
    type: 'code',
    language: 'typescript'
  });
  
  // Generate resource routes
  serverFiles.push({
    name: 'resources.ts',
    path: '/src/routes/',
    content: `import express from 'express';
import { proxyRequest, convertToMcpResource${config.rateLimitingEnabled ? ', rateLimiter' : ''} } from '../services/proxyService';

export const resourceRouter = express.Router();

${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'resource' && endpoint.selected !== false)
  .map(endpoint => {
    const params = endpoint.parameters
      .filter(param => param.required)
      .map(param => param.name)
      .join(', ');
    
    return `// ${endpoint.description || endpoint.path}
resourceRouter.get('${endpoint.path}', async (req, res) => {
  try {
    ${config.rateLimitingEnabled ? `
    // Check rate limit
    const clientId = req.headers['x-client-id'] as string || 'default';
    if (!rateLimiter(clientId)) {
      return res.status(429).json({ 
        error: 'Too many requests. Please try again later.'
      });
    }
    ` : ''}

    // Extract parameters from query
    const queryParams = req.query;
    
    // Make the request to the target API
    const targetPath = '${endpoint.path.replace(/^\//, '')}';
    const data = await proxyRequest(targetPath, 'GET', queryParams);
    
    // Convert and return data in MCP-compliant format
    res.json(convertToMcpResource(data, '${endpoint.path}'));
  } catch (error: any) {
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});
`}).join('\n')}

export default resourceRouter;
`,
    type: 'code',
    language: 'typescript'
  });
  
  // Generate tool routes
  serverFiles.push({
    name: 'tools.ts',
    path: '/src/routes/',
    content: `import express from 'express';
import { proxyRequest, convertToMcpToolResponse${config.rateLimitingEnabled ? ', rateLimiter' : ''} } from '../services/proxyService';

export const toolRouter = express.Router();

${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'tool' && endpoint.selected !== false)
  .map(endpoint => {
    const params = endpoint.parameters
      .filter(param => param.required)
      .map(param => param.name)
      .join(', ');
    
    return `// ${endpoint.description || endpoint.path}
toolRouter.post('${endpoint.path}', async (req, res) => {
  try {
    ${config.rateLimitingEnabled ? `
    // Check rate limit
    const clientId = req.headers['x-client-id'] as string || 'default';
    if (!rateLimiter(clientId)) {
      return res.status(429).json({ 
        error: 'Too many requests. Please try again later.'
      });
    }
    ` : ''}

    // Extract request body
    const requestBody = req.body;
    
    // Make the request to the target API
    const targetPath = '${endpoint.path.replace(/^\//, '')}';
    const data = await proxyRequest(targetPath, '${endpoint.method}', null, requestBody);
    
    // Convert and return data in MCP-compliant format
    res.json(convertToMcpToolResponse(data, '${endpoint.path}'));
  } catch (error: any) {
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});
`}).join('\n')}

export default toolRouter;
`,
    type: 'code',
    language: 'typescript'
  });

  return {
    success: true,
    files: serverFiles
  };
};
