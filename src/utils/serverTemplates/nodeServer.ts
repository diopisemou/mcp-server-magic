
import { ServerConfig, ServerFile, GenerationResult } from '@/types';

/**
 * Generate Node.js/Express server files based on the given configuration
 */
export const generateNodeServer = (
  config: ServerConfig
): GenerationResult => {
  const serverFiles: ServerFile[] = [];
  const { language, authentication } = config;

  // Use lowercase for language comparison
  const isTypescript = language.toLowerCase() === 'typescript';
  const fileExt = isTypescript ? 'ts' : 'js';

  // Generate package.json
  serverFiles.push({
    name: 'package.json',
    path: 'package.json',
    content: JSON.stringify(
      {
        name: config.name.toLowerCase().replace(/\s+/g, '-'),
        version: '1.0.0',
        description: config.description || 'MCP Server generated by MCP Server Generator',
        main: isTypescript ? 'dist/index.js' : 'src/index.js',
        scripts: {
          start: isTypescript ? 'node dist/index.js' : 'node src/index.js',
          build: isTypescript ? 'tsc' : 'echo "No build step needed"',
          dev: isTypescript ? 'ts-node src/index.ts' : 'nodemon src/index.js'
        },
        dependencies: {
          '@anthropic-ai/sdk': '^0.8.0',
          'express': '^4.18.2',
          'dotenv': '^16.3.1',
          'cors': '^2.8.5',
          ...(isTypescript ? { 'typescript': '^5.0.4' } : {}),
          ...(isTypescript ? { 'ts-node': '^10.9.1' } : {}),
          ...(isTypescript ? { '@types/express': '^4.17.17' } : {}),
          ...(isTypescript ? { '@types/cors': '^2.8.13' } : {})
        }
      },
      null,
      2
    ),
    type: 'config',
    language: 'json'
  });

  // Generate .env file
  serverFiles.push({
    name: '.env',
    path: '.env',
    content: `# MCP Server Configuration
PORT=3000
${authentication.type !== 'None' ? `API_KEY=${config.authSecret || 'your-api-key'}` : ''}
`,
    type: 'config',
    language: 'plaintext'
  });

  // Generate README.md
  serverFiles.push({
    name: 'README.md',
    path: 'README.md',
    content: `# ${config.name}

This is a Model Context Protocol (MCP) server generated by MCP Server Generator.

## Getting Started

1. Install dependencies:
   \`\`\`
   npm install
   \`\`\`

2. ${isTypescript ? 'Build the project:' : 'Start the server:'}
   \`\`\`
   ${isTypescript ? 'npm run build' : 'npm start'}
   \`\`\`

${isTypescript ? '3. Start the server:\n   ```\n   npm start\n   ```\n' : ''}

## Available Endpoints

${config.endpoints.map(endpoint => `- \`${endpoint.method} ${endpoint.path}\`: ${endpoint.description}`).join('\n')}

## Authentication

${authentication.type === 'None' 
  ? 'This server does not require authentication.' 
  : `This server uses ${authentication.type} authentication.`}
`,
    type: 'documentation',
    language: 'markdown'
  });

  // Generate server files
  if (isTypescript) {
    // Generate TypeScript files
    serverFiles.push({
      name: 'tsconfig.json',
      path: 'tsconfig.json',
      content: JSON.stringify(
        {
          compilerOptions: {
            target: 'es2020',
            module: 'commonjs',
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
            outDir: 'dist'
          },
          include: ['src/**/*'],
          exclude: ['node_modules']
        },
        null,
        2
      ),
      type: 'config',
      language: 'json'
    });
    
    // Generate index.ts
    serverFiles.push({
      name: 'index.ts',
      path: 'src/index.ts',
      content: `import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { resourceRoutes } from './routes/resourceRoutes';
import { toolRoutes } from './routes/toolRoutes';
${authentication.type !== 'None' ? "import { authenticate } from './middleware/auth';" : ''}

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

// MCP Server endpoints
app.get('/', (req, res) => {
  res.json({
    name: '${config.name}',
    description: '${config.description || 'MCP Server'}',
    capabilities: {
      resources: [${config.endpoints.filter(e => e.mcpType === 'resource').map(e => `'${e.path}'`).join(', ')}],
      tools: [${config.endpoints.filter(e => e.mcpType === 'tool').map(e => `'${e.path}'`).join(', ')}]
    }
  });
});

${authentication.type !== 'None' ? "app.use('/mcp', authenticate);" : ''}
app.use('/mcp/resources', resourceRoutes);
app.use('/mcp/tools', toolRoutes);

app.listen(port, () => {
  console.log(\`MCP Server running at http://localhost:\${port}\`);
});
`,
      type: 'code',
      language: 'typescript'
    });
    
    // Generate auth middleware if needed
    if (authentication.type !== 'None') {
      serverFiles.push({
        name: 'auth.ts',
        path: 'src/middleware/auth.ts',
        content: `import { Request, Response, NextFunction } from 'express';

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
  const apiKey = ${authentication.location === 'header' 
    ? `req.headers['${authentication.name || 'x-api-key'}']` 
    : `req.query['${authentication.name || 'api_key'}']`};
  
  if (!apiKey || apiKey !== process.env.API_KEY) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  next();
};
`,
        type: 'code',
        language: 'typescript'
      });
    }
    
    // Generate resource routes
    serverFiles.push({
      name: 'resourceRoutes.ts',
      path: 'src/routes/resourceRoutes.ts',
      content: `import express from 'express';

const router = express.Router();

${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'resource' && endpoint.selected !== false)
  .map(endpoint => {
    const params = endpoint.parameters
      .filter(param => param.required)
      .map(param => param.name)
      .join(', ');
    
    return `// ${endpoint.description || endpoint.path}
router.get('${endpoint.path}', async (req, res) => {
  try {
    // TODO: Implement the resource handling logic
    ${params ? `const { ${params} } = req.query;` : ''}
    
    res.json({
      data: {
        resourceId: '${endpoint.path}',
        ${params ? `${params},` : ''}
        // Add your resource data here
      }
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});
`}).join('\n')}

export { router as resourceRoutes };
`,
        type: 'code',
        language: 'typescript'
      });
    
    // Generate tool routes
    serverFiles.push({
      name: 'toolRoutes.ts',
      path: 'src/routes/toolRoutes.ts',
      content: `import express from 'express';

const router = express.Router();

${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'tool' && endpoint.selected !== false)
  .map(endpoint => {
    const params = endpoint.parameters
      .filter(param => param.required)
      .map(param => param.name)
      .join(', ');
    
    return `// ${endpoint.description || endpoint.path}
router.post('${endpoint.path}', async (req, res) => {
  try {
    ${params ? `const { ${params} } = req.body;` : ''}
    
    // TODO: Implement the tool handling logic
    
    res.json({
      result: {
        toolId: '${endpoint.path}',
        ${params ? `${params},` : ''}
        // Add your tool result data here
      }
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});
`}).join('\n')}

export { router as toolRoutes };
`,
        type: 'code',
        language: 'typescript'
      });
  } else {
    // Generate JavaScript files
    serverFiles.push({
      name: 'index.js',
      path: 'src/index.js',
      content: `const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { resourceRoutes } = require('./routes/resourceRoutes');
const { toolRoutes } = require('./routes/toolRoutes');
${authentication.type !== 'None' ? "const { authenticate } = require('./middleware/auth');" : ''}

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

// MCP Server endpoints
app.get('/', (req, res) => {
  res.json({
    name: '${config.name}',
    description: '${config.description || 'MCP Server'}',
    capabilities: {
      resources: [${config.endpoints.filter(e => e.mcpType === 'resource').map(e => `'${e.path}'`).join(', ')}],
      tools: [${config.endpoints.filter(e => e.mcpType === 'tool').map(e => `'${e.path}'`).join(', ')}]
    }
  });
});

${authentication.type !== 'None' ? "app.use('/mcp', authenticate);" : ''}
app.use('/mcp/resources', resourceRoutes);
app.use('/mcp/tools', toolRoutes);

app.listen(port, () => {
  console.log(\`MCP Server running at http://localhost:\${port}\`);
});
`,
        type: 'code',
        language: 'javascript'
      });
    
    // Generate auth middleware if needed
    if (authentication.type !== 'None') {
      serverFiles.push({
        name: 'auth.js',
        path: 'src/middleware/auth.js',
        content: `const authenticate = (req, res, next) => {
  const apiKey = ${authentication.location === 'header' 
    ? `req.headers['${authentication.name || 'x-api-key'}']` 
    : `req.query['${authentication.name || 'api_key'}']`};
  
  if (!apiKey || apiKey !== process.env.API_KEY) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  next();
};

module.exports = { authenticate };
`,
        type: 'code',
        language: 'javascript'
      });
    }
    
    // Generate resource routes
    serverFiles.push({
      name: 'resourceRoutes.js',
      path: 'src/routes/resourceRoutes.js',
      content: `const express = require('express');

const router = express.Router();

${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'resource' && endpoint.selected !== false)
  .map(endpoint => {
    const params = endpoint.parameters
      .filter(param => param.required)
      .map(param => param.name)
      .join(', ');
    
    return `// ${endpoint.description || endpoint.path}
router.get('${endpoint.path}', async (req, res) => {
  try {
    // TODO: Implement the resource handling logic
    ${params ? `const { ${params} } = req.query;` : ''}
    
    res.json({
      data: {
        resourceId: '${endpoint.path}',
        ${params ? `${params},` : ''}
        // Add your resource data here
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
`}).join('\n')}

module.exports = { resourceRoutes: router };
`,
        type: 'code',
        language: 'javascript'
      });
    
    // Generate tool routes
    serverFiles.push({
      name: 'toolRoutes.js',
      path: 'src/routes/toolRoutes.js',
      content: `const express = require('express');

const router = express.Router();

${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'tool' && endpoint.selected !== false)
  .map(endpoint => {
    const params = endpoint.parameters
      .filter(param => param.required)
      .map(param => param.name)
      .join(', ');
    
    return `// ${endpoint.description || endpoint.path}
router.post('${endpoint.path}', async (req, res) => {
  try {
    ${params ? `const { ${params} } = req.body;` : ''}
    
    // TODO: Implement the tool handling logic
    
    res.json({
      result: {
        toolId: '${endpoint.path}',
        ${params ? `${params},` : ''}
        // Add your tool result data here
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
`}).join('\n')}

module.exports = { toolRoutes: router };
`,
        type: 'code',
        language: 'javascript'
      });
  }

  return {
    success: true,
    files: serverFiles
  };
};
