import { ServerConfig, ServerFile, GenerationResult } from '@/types';

/**
 * Generate Go server files based on the given configuration
 */
export const generateGoServer = (config: ServerConfig): GenerationResult => {
  const serverFiles: ServerFile[] = [];
  const { authentication } = config;

  // Generate go.mod file
  serverFiles.push({
    name: 'go.mod',
    path: '/',
    content: `module github.com/${config.name.toLowerCase().replace(/\s+/g, '-')}

go 1.21

require (
	github.com/gorilla/mux v1.8.1
	github.com/joho/godotenv v1.5.1
	github.com/rs/cors v1.10.1
)
`,
    type: 'config',
    language: 'go'
  });

  // Generate main.go
  serverFiles.push({
    name: 'main.go',
    path: '/',
    content: `package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/gorilla/mux"
	"github.com/joho/godotenv"
	"github.com/rs/cors"
)

// ServerInfo represents information about the MCP server
type ServerInfo struct {
	Name         string   \`json:"name"\`
	Description  string   \`json:"description"\`
	Capabilities struct {
		Resources []string \`json:"resources"\`
		Tools     []string \`json:"tools"\`
	} \`json:"capabilities"\`
}

func main() {
	// Load .env file if it exists
	loadEnv()

	// Create router
	r := mux.NewRouter()

	// Get port from environment or use default
	port := getEnvWithDefault("PORT", "8080")

	// Server info
	serverInfo := ServerInfo{
		Name:        "${config.name}",
		Description: "${config.description || 'MCP Server generated by MCP Server Generator'}",
	}
	
	// Register capabilities
	serverInfo.Capabilities.Resources = []string{${config.endpoints
    .filter(e => e.mcpType === 'resource')
    .map(e => `"${e.path}"`)
    .join(', ')}}
	serverInfo.Capabilities.Tools = []string{${config.endpoints
    .filter(e => e.mcpType === 'tool')
    .map(e => `"${e.path}"`)
    .join(', ')}}

	// Root endpoint returns server info
	r.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		respondWithJSON(w, http.StatusOK, serverInfo)
	})

	// MCP Base routes
	mcpRouter := r.PathPrefix("/mcp").Subrouter()
${authentication.type !== 'None' ? `
	// Add authentication middleware if needed
	mcpRouter.Use(authMiddleware)` : ''}

	// MCP Resources router
	resourceRouter := mcpRouter.PathPrefix("/resources").Subrouter()
	
	// MCP Tools router
	toolRouter := mcpRouter.PathPrefix("/tools").Subrouter()

	// Register resource endpoints
${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'resource' && endpoint.selected !== false)
  .map(endpoint => {
    const path = endpoint.path.replace(/\{([^}]+)\}/g, '{$1}');
    const funcName = 'handle' + camelize(path.replace(/\//g, '_'));
    return `	resourceRouter.HandleFunc("${path}", ${funcName}).Methods("GET")\n`;
  }).join('')}

	// Register tool endpoints
${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'tool' && endpoint.selected !== false)
  .map(endpoint => {
    const path = endpoint.path.replace(/\{([^}]+)\}/g, '{$1}');
    const funcName = 'handle' + camelize(path.replace(/\//g, '_'));
    return `	toolRouter.HandleFunc("${path}", ${funcName}).Methods("${endpoint.method}")\n`;
  }).join('')}

	// Apply CORS middleware
	c := cors.New(cors.Options{
		AllowedOrigins:   []string{"*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Content-Type", "Authorization"},
		AllowCredentials: true,
	})

	// Start server
	handler := c.Handler(r)
	log.Printf("MCP Server starting on port %s", port)
	log.Fatal(http.ListenAndServe(":" + port, handler))
}

// Helper function to load .env file
func loadEnv() {
	// Find .env file
	env := ".env"
	if _, err := os.Stat(env); os.IsNotExist(err) {
		// Try to look in parent directory
		parent := filepath.Join("..", ".env")
		if _, err := os.Stat(parent); err == nil {
			env = parent
		} else {
			log.Println("No .env file found, using environment variables")
			return
		}
	}

	// Load .env file
	err := godotenv.Load(env)
	if err != nil {
		log.Printf("Error loading .env file: %v", err)
	} else {
		log.Printf("Loaded environment from %s", env)
	}
}

// Helper function to get environment variable with default
func getEnvWithDefault(key, defaultValue string) string {
	value := os.Getenv(key)
	if value == "" {
		return defaultValue
	}
	return value
}

// Helper function to respond with JSON
func respondWithJSON(w http.ResponseWriter, status int, payload interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	
	// Convert payload to JSON
	response, err := json.Marshal(payload)
	if err != nil {
		log.Printf("Error marshaling JSON: %v", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	
	w.Write(response)
}
${authentication.type !== 'None' ? `
// Authentication middleware
func authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var authValue string
		${authentication.location === 'header' 
          ? `// Get API key from header
		authHeader := r.Header.Get("${authentication.name || 'X-Api-Key'}")
		if strings.HasPrefix(authHeader, "Bearer ") {
			authValue = strings.TrimPrefix(authHeader, "Bearer ")
		} else {
			authValue = authHeader
		}`
          : `// Get API key from query parameter
		authValue = r.URL.Query().Get("${authentication.name || 'api_key'}")`}
		
		expectedKey := os.Getenv("API_KEY")
		if expectedKey == "" {
			log.Println("Warning: API_KEY environment variable not set")
			next.ServeHTTP(w, r)
			return
		}
		
		if authValue == "" || authValue != expectedKey {
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}
		
		next.ServeHTTP(w, r)
	})
}` : ''}
`,
    type: 'code',
    language: 'go'
  });

  // Generate endpoint handlers
  serverFiles.push({
    name: 'handlers.go',
    path: '/',
    content: `package main

import (
	"encoding/json"
	"net/http"
	"github.com/gorilla/mux"
)

// Standard response format
type Response struct {
	Success bool        \`json:"success"\`
	Data    interface{} \`json:"data,omitempty"\`
	Error   string      \`json:"error,omitempty"\`
}

// Resource handlers
${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'resource' && endpoint.selected !== false)
  .map(endpoint => {
    const path = endpoint.path;
    const funcName = 'handle' + camelize(path.replace(/\//g, '_'));
    const pathParams = extractPathParams(path);
    
    return `
// ${endpoint.description || 'Handler for ' + path}
func ${funcName}(w http.ResponseWriter, r *http.Request) {
	// Get path parameters
	vars := mux.Vars(r)
${pathParams.map(param => `	${param} := vars["${param}"]`).join('\n')}
	
	// Get query parameters${endpoint.parameters
    .filter(param => !pathParams.includes(param.name) && param.required)
    .map(param => `
	${param.name} := r.URL.Query().Get("${param.name}")
	if ${param.name} == "" {
		http.Error(w, "Missing required parameter: ${param.name}", http.StatusBadRequest)
		return
	}`).join('')}
	
	// Return sample response
	response := Response{
		Success: true,
		Data: map[string]interface{}{
			"resourceId": "${path}",${pathParams.length ? `
			"params": map[string]string{
				${pathParams.map(param => `"${param}": ${param}`).join(',\n\t\t\t\t')}
			},` : ''}
			// TODO: Add your resource data here
		},
	}
	
	respondWithJSON(w, http.StatusOK, response)
}
`}).join('\n')}

// Tool handlers
${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'tool' && endpoint.selected !== false)
  .map(endpoint => {
    const path = endpoint.path;
    const funcName = 'handle' + camelize(path.replace(/\//g, '_'));
    const pathParams = extractPathParams(path);
    
    return `
// ${endpoint.description || 'Handler for ' + path}
func ${funcName}(w http.ResponseWriter, r *http.Request) {
	// Get path parameters
	vars := mux.Vars(r)
${pathParams.map(param => `	${param} := vars["${param}"]`).join('\n')}
	
	// Parse request body
	var requestData map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&requestData); err != nil && r.ContentLength > 0 {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	
	// Return sample response
	response := Response{
		Success: true,
		Data: map[string]interface{}{
			"toolId": "${path}",${pathParams.length ? `
			"params": map[string]string{
				${pathParams.map(param => `"${param}": ${param}`).join(',\n\t\t\t\t')}
			},` : ''}
			"requestData": requestData,
			// TODO: Add your tool result data here
		},
	}
	
	respondWithJSON(w, http.StatusOK, response)
}
`}).join('\n')}

// Helper function to camelize a string
func camelize(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
`,
    type: 'code',
    language: 'go'
  });

  // Generate .env file
  serverFiles.push({
    name: '.env',
    path: '/',
    content: `# MCP Server Configuration
PORT=8080
${authentication.type !== 'None' ? `API_KEY=${config.authSecret || 'your-api-key-here'}` : ''}
`,
    type: 'config',
    language: 'plaintext'
  });

  // Generate README.md
  serverFiles.push({
    name: 'README.md',
    path: '/',
    content: `# ${config.name}

This is a Model Context Protocol (MCP) server generated by MCP Server Generator.

## Getting Started

1. Install Go 1.21 or later if not already installed:
   https://golang.org/doc/install

2. Install dependencies:
   \`\`\`
   go mod download
   \`\`\`

3. Start the server:
   \`\`\`
   go run .
   \`\`\`

## Available Endpoints

${config.endpoints.map(endpoint => `- \`${endpoint.method} ${endpoint.path}\`: ${endpoint.description}`).join('\n')}

## Authentication

${authentication.type === 'None' 
  ? 'This server does not require authentication.' 
  : `This server uses ${authentication.type} authentication.`}

## Building for Production

To build a production binary:

\`\`\`
go build -o mcp-server .
\`\`\`

## Docker Support

To build and run with Docker:

\`\`\`
docker build -t ${config.name.toLowerCase().replace(/\s+/g, '-')} .
docker run -p 8080:8080 --env-file .env ${config.name.toLowerCase().replace(/\s+/g, '-')}
\`\`\`

## Environment Variables

- \`PORT\`: The port to run the server on (default: 8080)
${authentication.type !== 'None' ? '- `API_KEY`: Authentication key for securing your MCP server' : ''}
`,
    type: 'documentation',
    language: 'markdown'
  });

  // Generate Dockerfile
  serverFiles.push({
    name: 'Dockerfile',
    path: '/',
    content: `FROM golang:1.21-alpine AS builder

WORKDIR /app

# Copy go.mod and go.sum files
COPY go.mod ./

# Download dependencies
RUN go mod download

# Copy source code
COPY *.go ./

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -o mcp-server .

# Use a minimal image for the final stage
FROM alpine:latest

WORKDIR /app

# Copy the binary from the builder stage
COPY --from=builder /app/mcp-server .

# Copy .env file if it exists
COPY .env* ./

# Expose port
EXPOSE 8080

# Start the application
CMD ["./mcp-server"]
`,
    type: 'config',
    language: 'docker'
  });

  // Helper function to extract path parameters
  function extractPathParams(path: string): string[] {
    const params: string[] = [];
    const regex = /\{([^}]+)\}/g;
    let match;
    
    while ((match = regex.exec(path)) !== null) {
      params.push(match[1]);
    }
    
    return params;
  }

  // Helper function to camelize a string
  function camelize(str: string): string {
    return str
      .replace(/[^a-zA-Z0-9]/g, '_')
      .replace(/(?:^\w|[A-Z]|\b\w)/g, function(word, index) {
        return index === 0 ? word.toUpperCase() : word.toUpperCase();
      })
      .replace(/\s+/g, '');
  }

  return {
    success: true,
    files: serverFiles
  };
};
