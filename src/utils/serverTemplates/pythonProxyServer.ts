import { ServerConfig, ServerFile, GenerationResult } from '@/types';

// Extended interface for proxy-specific properties
interface ExtendedServerConfig extends ServerConfig {
  mode?: 'direct' | 'proxy';
  targetBaseUrl?: string;
  cacheEnabled?: boolean;
  rateLimitingEnabled?: boolean;
}

/**
 * Generate Python/FastAPI proxy server files based on the given configuration
 * This creates an MCP server that proxies requests to an existing API using the official MCP library
 */
export const generatePythonProxyServer = (config: ExtendedServerConfig): GenerationResult => {
  const serverFiles: ServerFile[] = [];
  const { authentication, targetBaseUrl } = config;

  // Generate requirements.txt
  serverFiles.push({
    name: 'requirements.txt',
    path: '/',
    content: `fastapi==0.103.1
uvicorn==0.23.2
python-dotenv==1.0.0
httpx==0.25.0
pydantic==2.3.0
python-jose[cryptography]==3.3.0
cachetools==5.3.1
${config.cacheEnabled ? 'cachetools==5.3.1' : ''}
`,
    type: 'config',
    language: 'plaintext'
  });

  // Generate .env file
  serverFiles.push({
    name: '.env',
    path: '/',
    content: `# MCP Proxy Server Configuration
PORT=3000
TARGET_API_URL=${targetBaseUrl || 'https://api.example.com'}
${authentication.type !== 'None' ? `MCP_API_KEY=${config.authSecret || 'your-mcp-api-key'}` : ''}
${authentication.type !== 'None' ? `TARGET_API_KEY=your-target-api-key` : ''}
`,
    type: 'config',
    language: 'plaintext'
  });

  // Generate README.md
  serverFiles.push({
    name: 'README.md',
    path: '/',
    content: `# ${config.name}

This is a Model Context Protocol (MCP) proxy server generated by MCP Server Generator.

## Description

This server acts as a proxy between MCP clients (like Claude) and your existing API (${targetBaseUrl || 'your API'}). It translates MCP requests into API calls and converts the responses back to MCP format.

## Getting Started

1. Install dependencies:
   \`\`\`
   pip install -r requirements.txt
   \`\`\`

2. Configure the \`.env\` file with your target API details.

3. Start the server:
   \`\`\`
   uvicorn main:app --reload
   \`\`\`

## Available Endpoints

${config.endpoints.map(endpoint => `- \`${endpoint.method} ${endpoint.path}\`: ${endpoint.description}`).join('\n')}

## Authentication

${authentication.type === 'None' 
  ? 'This MCP server does not require authentication. However, you may need to configure authentication for the target API in the proxy settings.' 
  : `This MCP server uses ${authentication.type} authentication. Additionally, you can configure authentication for the target API in the .env file.`}

## Features

${config.cacheEnabled ? '- Response caching is enabled to improve performance.\n' : ''}${config.rateLimitingEnabled ? '- Rate limiting is configured to avoid overloading the target API.\n' : ''}
`,
    type: 'documentation',
    language: 'markdown'
  });

  // Update requirements.txt to include MCP library
  serverFiles.push({
    name: 'requirements.txt',
    path: '/',
    content: `mcp-server==0.1.0
httpx==0.25.0
python-dotenv==1.0.0
pydantic==2.3.0
${config.cacheEnabled ? 'cachetools==5.3.1' : ''}
`,
    type: 'config',
    language: 'plaintext'
  });
  
  // Generate main.py using MCP library
  serverFiles.push({
    name: 'main.py',
    path: '/',
    content: `#!/usr/bin/env python3
import os
import json
import asyncio
from typing import Dict, Any, Optional, List, Union
from dotenv import load_dotenv
from mcp_server import Server, StdioTransport, HttpTransport
from mcp_server.schemas import (
    ListResourcesRequest, ListResourcesResponse,
    ReadResourceRequest, ReadResourceResponse,
    ListToolsRequest, ListToolsResponse,
    CallToolRequest, CallToolResponse,
    ErrorResponse, Error
)
${config.cacheEnabled ? 'from cachetools import TTLCache' : ''}

# Import proxy service
from services.proxy_service import proxy_request

load_dotenv()

# Get configuration
TARGET_API_URL = os.getenv("TARGET_API_URL")
if not TARGET_API_URL:
    raise ValueError("TARGET_API_URL environment variable is not set")

${authentication.type !== 'None' ? 'MCP_API_KEY = os.getenv("MCP_API_KEY", "default-key")' : ''}
${config.cacheEnabled ? '# Create cache with TTL of 5 minutes (300 seconds)\ncache = TTLCache(maxsize=1000, ttl=300)' : ''}

class MCPProxyServer:
    """MCP Proxy Server using the official MCP library"""
    
    def __init__(self):
        # Initialize the MCP server
        self.server = Server(
            name="${config.name}",
            version="1.0.0",
            description="${config.description || 'MCP Proxy Server generated by MCP Server Generator'}"
        )
        
        # Setup request handlers
        self.setup_handlers()
    
    def setup_handlers(self):
        """Setup all MCP request handlers"""
        
        @self.server.request_handler(ListResourcesRequest)
        async def list_resources(request):
            """List available resources"""
            resources = [
                {
                    "uri": path,
                    "name": desc or path,
                    "description": desc or "Resource endpoint"
                }
                for path, desc in [
                    ${config.endpoints
                      .filter(e => e.mcpType === 'resource' && e.selected !== false)
                      .map(e => `("${e.path}", "${e.description || ''}")`)
                      .join(',\n                    ')}
                ]
            ]
            
            return ListResourcesResponse(resources=resources)
        
        @self.server.request_handler(ReadResourceRequest)
        async def read_resource(request):
            """Read a specific resource"""
            try:
                # Extract resource URI and parameters
                resource_uri = request.uri
                parts = resource_uri.split('?')
                path = parts[0]
                
                # Handle parameters if present
                params = {}
                if len(parts) > 1:
                    query_string = parts[1]
                    params = {k: v for k, v in [p.split('=') for p in query_string.split('&') if '=' in p]}
                
                ${authentication.type !== 'None' ? `
                # Validate authentication if required
                if not self._authenticate(request.headers):
                    return ErrorResponse(
                        error=Error(code="unauthorized", message="Invalid API key")
                    )
                ` : ''}
                
                # Make the request to the target API
                response_data = await proxy_request(
                    path.lstrip('/'),  # Remove leading slash if present
                    "GET",
                    params
                )
                
                # Return in MCP format
                return ReadResourceResponse(
                    contents=[
                        {
                            "uri": resource_uri,
                            "mimeType": "application/json",
                            "text": json.dumps(response_data, indent=2)
                        }
                    ]
                )
            except Exception as e:
                return ErrorResponse(
                    error=Error(code="internal_error", message=f"Proxy error: {str(e)}")
                )
        
        @self.server.request_handler(ListToolsRequest)
        async def list_tools(request):
            """List available tools"""
            tools = []
            
            # Add tools from configuration
            ${config.endpoints
                .filter(e => e.mcpType === 'tool' && e.selected !== false)
                .map(e => {
                  const paramProperties = e.parameters
                    .filter(p => p.required)
                    .map(p => `"${p.name}": { 
                        "type": "${p.type === 'number' ? 'number' : p.type === 'boolean' ? 'boolean' : 'string'}",
                        "description": "${p.description || p.name}" 
                      }`);
                    
                  return `tools.append({
                "name": "${e.path}",
                "description": "${e.description || 'Tool endpoint'}",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        ${paramProperties.join(',\n                        ')}
                    },
                    "required": [${e.parameters.filter(p => p.required).map(p => `"${p.name}"`).join(', ')}]
                }
            })`}).join('\n            ')}
            
            return ListToolsResponse(tools=tools)
        
        @self.server.request_handler(CallToolRequest)
        async def call_tool(request):
            """Execute a tool"""
            try:
                # Find the endpoint that matches the requested tool
                tool_name = request.name
                
                ${authentication.type !== 'None' ? `
                # Validate authentication if required
                if not self._authenticate(request.headers):
                    return ErrorResponse(
                        error=Error(code="unauthorized", message="Invalid API key")
                    )
                ` : ''}
                
                # Get the method for this tool
                tool_endpoint = None
                for endpoint in [
                    ${config.endpoints
                      .filter(e => e.mcpType === 'tool' && e.selected !== false)
                      .map(e => `{"path": "${e.path}", "method": "${e.method}"}`)
                      .join(',\n                    ')}
                ]:
                    if endpoint["path"] == tool_name:
                        tool_endpoint = endpoint
                        break
                
                if not tool_endpoint:
                    return ErrorResponse(
                        error=Error(code="not_found", message=f"Tool {tool_name} not found")
                    )
                
                # Make the request to the target API
                response_data = await proxy_request(
                    tool_name.lstrip('/'),  # Remove leading slash if present
                    tool_endpoint["method"],
                    None,
                    request.arguments
                )
                
                # Return in MCP format
                return CallToolResponse(
                    content=[
                        {
                            "type": "text",
                            "text": json.dumps(response_data, indent=2)
                        }
                    ]
                )
            except Exception as e:
                return ErrorResponse(
                    error=Error(code="internal_error", message=f"Proxy error: {str(e)}")
                )
        
        ${authentication.type !== 'None' ? `
        def _authenticate(self, headers):
            """Validate the API key"""
            api_key = headers.get("${authentication.name || 'x-api-key'}")
            return api_key == MCP_API_KEY
        ` : ''}
    
    async def run(self):
        """Run the MCP server"""
        # Choose transport based on environment
        use_stdio = os.getenv("USE_STDIO", "false").lower() == "true"
        port = int(os.getenv("PORT", "3000"))
        
        if use_stdio:
            # Use stdio transport for LLM integration
            transport = StdioTransport()
            print("Starting MCP server with stdio transport...", file=sys.stderr)
        else:
            # Use HTTP transport for direct usage
            transport = HttpTransport(port=port)
            print(f"Starting MCP server on http://localhost:{port}...", file=sys.stderr)
        
        print(f"Proxying requests to {TARGET_API_URL}", file=sys.stderr)
        
        await self.server.serve(transport)

if __name__ == "__main__":
    import sys
    
    # Create and run the server
    server = MCPProxyServer()
    
    if sys.platform == 'win32':
        # Windows-specific event loop policy
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    asyncio.run(server.run())
`,
    type: 'code',
    language: 'python'
  });

  // Generate auth middleware if needed
  if (authentication.type !== 'None') {
    serverFiles.push({
      name: 'auth.py',
      path: '/middleware/',
      content: `from fastapi import Header, HTTPException, Request, Depends
import os
from typing import Optional

async def api_key_auth(${authentication.location === 'header' 
    ? `${authentication.name || 'x_api_key'}: str = Header(None, alias="${authentication.name || 'x-api-key'}")` 
    : `request: Request`}):
    """Validate API key for protected endpoints"""
    api_key = ${authentication.location === 'header' 
        ? authentication.name || 'x_api_key' 
        : `request.query_params.get("${authentication.name || 'api_key'}")`}
    expected_api_key = os.getenv("MCP_API_KEY")
    
    if not api_key or api_key != expected_api_key:
        raise HTTPException(status_code=401, detail="Invalid API key")
        
    return True
`,
      type: 'code',
      language: 'python'
    });
  }

  // Generate proxy service
  serverFiles.push({
    name: 'proxy_service.py',
    path: '/services/',
    content: `import httpx
import os
import json
from typing import Dict, Any, Optional, List, Union
from fastapi import HTTPException
${config.cacheEnabled ? 'from cachetools import TTLCache\n' : ''}
${config.rateLimitingEnabled ? 'import time\nfrom collections import defaultdict\n' : ''}

# Get the target API URL from environment
TARGET_API_URL = os.getenv("TARGET_API_URL")
TARGET_API_KEY = os.getenv("TARGET_API_KEY")

# Create HTTP client
client = httpx.AsyncClient(base_url=TARGET_API_URL, timeout=30.0)

${config.cacheEnabled ? `
# Create cache with TTL of 5 minutes (300 seconds)
cache = TTLCache(maxsize=1000, ttl=300)
` : ''}

${config.rateLimitingEnabled ? `
# Simple rate limiter
RATE_LIMIT_WINDOW = 60  # seconds
RATE_LIMIT_MAX_REQUESTS = 60  # requests per minute
request_counts = defaultdict(list)

def check_rate_limit(client_id: str = "default") -> bool:
    """Check if the rate limit has been exceeded"""
    current_time = time.time()
    
    # Remove timestamps outside the window
    request_counts[client_id] = [
        timestamp for timestamp in request_counts[client_id] 
        if timestamp > current_time - RATE_LIMIT_WINDOW
    ]
    
    # Check if rate limit exceeded
    if len(request_counts[client_id]) >= RATE_LIMIT_MAX_REQUESTS:
        return False
    
    # Record this request
    request_counts[client_id].append(current_time)
    return True
` : ''}

def generate_cache_key(path: str, params: Dict[str, Any]) -> str:
    """Generate a cache key based on the path and parameters"""
    return f"{path}-{json.dumps(params, sort_keys=True)}"

async def proxy_request(
    path: str,
    method: str = "GET",
    params: Optional[Dict[str, Any]] = None,
    data: Optional[Dict[str, Any]] = None
) -> Any:
    """Forward a request to the target API and return the response"""
    try:
        # Remove leading slash if present
        if path.startswith("/"):
            path = path[1:]
            
        # Full URL
        url = f"{path}"
        
        # Generate cache key for GET requests
        cache_key = None
        if method == "GET" and params:
            cache_key = generate_cache_key(url, params or {})
            
        ${config.cacheEnabled ? `
        # Check cache for GET requests
        if method == "GET" and cache_key and cache_key in cache:
            print(f"Cache hit for {url}")
            return cache[cache_key]
        ` : ''}
        
        # Set headers
        headers = {}
        if TARGET_API_KEY:
            # You might need to adjust this based on the API's authentication method
            headers["X-API-Key"] = TARGET_API_KEY
            # Alternatively:
            # headers["Authorization"] = f"Bearer {TARGET_API_KEY}"
            
        # Make the request based on the method
        if method == "GET":
            response = await client.get(url, params=params, headers=headers)
        elif method == "POST":
            response = await client.post(url, json=data, headers=headers)
        elif method == "PUT":
            response = await client.put(url, json=data, headers=headers)
        elif method == "DELETE":
            response = await client.delete(url, params=params, headers=headers)
        else:
            raise ValueError(f"Unsupported method: {method}")
            
        # Check if the request was successful
        response.raise_for_status()
        
        # Parse the response
        response_data = response.json()
        
        ${config.cacheEnabled ? `
        # Cache the response for GET requests
        if method == "GET" and cache_key:
            cache[cache_key] = response_data
        ` : ''}
        
        return response_data
    except httpx.HTTPStatusError as e:
        # Handle HTTP errors (4xx, 5xx)
        error_detail = f"Target API responded with status {e.response.status_code}"
        try:
            error_body = e.response.json()
            if "message" in error_body:
                error_detail += f": {error_body['message']}"
        except Exception:
            pass
            
        raise HTTPException(status_code=e.response.status_code, detail=error_detail)
    except httpx.RequestError as e:
        # Handle network/connection errors
        raise HTTPException(status_code=503, detail=f"Error communicating with target API: {str(e)}")
    except Exception as e:
        # Handle all other errors
        raise HTTPException(status_code=500, detail=f"Proxy error: {str(e)}")

def convert_to_mcp_resource(data: Any, resource_id: str) -> Dict[str, Any]:
    """Convert API response to MCP resource format"""
    return {
        "success": True,
        "data": {
            "id": resource_id,
            "content": [
                {
                    "type": "text",
                    "text": json.dumps(data, indent=2)
                }
            ]
        }
    }

def convert_to_mcp_tool_response(data: Any, tool_id: str) -> Dict[str, Any]:
    """Convert API response to MCP tool response format"""
    return {
        "success": True,
        "result": {
            "id": tool_id,
            "content": [
                {
                    "type": "text",
                    "text": json.dumps(data, indent=2)
                }
            ]
        }
    }
`,
    type: 'code',
    language: 'python'
  });

  // Create __init__.py files for Python modules
  serverFiles.push({
    name: '__init__.py',
    path: '/middleware/',
    content: '',
    type: 'code',
    language: 'python'
  });

  serverFiles.push({
    name: '__init__.py',
    path: '/routes/',
    content: '',
    type: 'code',
    language: 'python'
  });

  serverFiles.push({
    name: '__init__.py',
    path: '/services/',
    content: '',
    type: 'code',
    language: 'python'
  });

  // Generate resource routes
  serverFiles.push({
    name: 'resources.py',
    path: '/routes/',
    content: `from fastapi import APIRouter, Query, HTTPException, Request, Response, Depends
from typing import Dict, Any, Optional, List
from services.proxy_service import proxy_request, convert_to_mcp_resource${config.rateLimitingEnabled ? ', check_rate_limit' : ''}

router = APIRouter()

${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'resource' && endpoint.selected !== false)
  .map(endpoint => {
    const params = endpoint.parameters
      .filter(param => param.required)
      .map(param => {
        const paramType = param.type === 'number' || param.type === 'integer' ? 'float' : 
                         param.type === 'boolean' ? 'bool' : 'str';
        return `${param.name}: ${paramType} = Query(None, description="${param.description || ''}")`;
      })
      .join(', ');
    
    return `
@router.get("${endpoint.path}")
async def ${endpoint.path.replace(/\//g, '_').replace(/-/g, '_').replace(/[{}]/g, '').trim() || 'get_resource'}(
    request: Request,
    ${params ? params + ',' : ''}
):
    """${endpoint.description || endpoint.path}"""
    try:
        ${config.rateLimitingEnabled ? `
        # Check rate limit
        client_id = request.headers.get("x-client-id", "default")
        if not check_rate_limit(client_id):
            raise HTTPException(
                status_code=429, 
                detail="Too many requests. Please try again later."
            )
        ` : ''}
        
        # Extract all query parameters
        query_params = dict(request.query_params)
        
        # Make the request to the target API
        target_path = "${endpoint.path.replace(/^\//, '')}"
        data = await proxy_request(target_path, "GET", query_params)
        
        # Convert and return response in MCP format
        return convert_to_mcp_resource(data, "${endpoint.path}")
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        # Convert other exceptions to HTTP exceptions
        raise HTTPException(status_code=500, detail=str(e))
`}).join('\n')}
`,
    type: 'code',
    language: 'python'
  });

  // Generate tool routes
  serverFiles.push({
    name: 'tools.py',
    path: '/routes/',
    content: `from fastapi import APIRouter, HTTPException, Request, Response, Depends
from typing import Dict, Any, Optional, List
from pydantic import BaseModel
from services.proxy_service import proxy_request, convert_to_mcp_tool_response${config.rateLimitingEnabled ? ', check_rate_limit' : ''}

router = APIRouter()

${config.endpoints
  .filter(endpoint => endpoint.mcpType === 'tool' && endpoint.selected !== false)
  .map(endpoint => {
    const requiredParams = endpoint.parameters.filter(param => param.required);
    const hasParams = requiredParams.length > 0;
    
    let content = '';
    
    if (hasParams) {
      // Create Pydantic model for required parameters
      content += `
class ${endpoint.path.replace(/\//g, '_').replace(/-/g, '_').replace(/[{}]/g, '').trim() || 'ToolParams'}(BaseModel):
    ${requiredParams.map(param => {
      const paramType = param.type === 'number' || param.type === 'integer' ? 'float' : 
                       param.type === 'boolean' ? 'bool' : 'str';
      return `${param.name}: ${paramType} # ${param.description || ''}`;
    }).join('\n    ')}
`;
    }
    
    content += `
@router.post("${endpoint.path}")
async def ${endpoint.path.replace(/\//g, '_').replace(/-/g, '_').replace(/[{}]/g, '').trim() || 'execute_tool'}(
    request: Request,
    ${hasParams ? `data: ${endpoint.path.replace(/\//g, '_').replace(/-/g, '_').replace(/[{}]/g, '').trim() || 'ToolParams'},` : ''}
):
    """${endpoint.description || endpoint.path}"""
    try:
        ${config.rateLimitingEnabled ? `
        # Check rate limit
        client_id = request.headers.get("x-client-id", "default")
        if not check_rate_limit(client_id):
            raise HTTPException(
                status_code=429, 
                detail="Too many requests. Please try again later."
            )
        ` : ''}
        
        # Get request body
        ${hasParams ? 'body_data = data.model_dump()' : 'body_data = await request.json()'}
        
        # Make the request to the target API
        target_path = "${endpoint.path.replace(/^\//, '')}"
        data = await proxy_request(target_path, "${endpoint.method}", None, body_data)
        
        # Convert and return response in MCP format
        return convert_to_mcp_tool_response(data, "${endpoint.path}")
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        # Convert other exceptions to HTTP exceptions
        raise HTTPException(status_code=500, detail=str(e))
`;
    
    return content;
  }).join('\n')}
`,
    type: 'code',
    language: 'python'
  });

  return {
    success: true,
    files: serverFiles
  };
};
