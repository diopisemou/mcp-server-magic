import { GenerationResult, ServerFile } from '@/types';
import { ExtendedServerConfig, DirectServerConfig } from '@/types/serverConfig';
import { BaseGenerator } from './baseGenerator';
import { TemplateManager } from './templateManager';

/**
 * Generator for TypeScript/Node.js servers
 * Implements the standard Node.js server generation
 */
export class NodeGenerator extends BaseGenerator {
  private templateManager: TemplateManager;
  
  constructor() {
    super();
    this.templateManager = new TemplateManager('typescript');
  }
  
  /**
   * Generate server files for TypeScript/Node.js
   * @param config Server configuration
   * @returns Generation result
   */
  generateServer(config: ExtendedServerConfig): GenerationResult {
    if (config.mode !== 'direct') {
      throw new Error('NodeGenerator only supports direct mode. Use NodeProxyGenerator for proxy mode.');
    }
    
    try {
      const serverFiles: ServerFile[] = [];
      const { authentication, endpoints } = config;
      
      // Add standard files
      serverFiles.push(this.generatePackageJson(config));
      serverFiles.push(this.generateReadme(config));
      serverFiles.push(this.generateEnvFile(config));
      serverFiles.push(this.generateTsConfig());
      
      // Add source files
      serverFiles.push(this.generateIndexFile(config));
      serverFiles.push(this.generateResourceRoutesFile(config));
      serverFiles.push(this.generateToolRoutesFile(config));
      
      // Add auth middleware if needed
      if (authentication.type !== 'None') {
        serverFiles.push(this.generateAuthMiddleware(config));
      }
      
      return {
        success: true,
        files: serverFiles
      };
    } catch (error) {
      console.error('Error generating Node.js server:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error generating Node.js server'
      };
    }
  }
  
  /**
   * Generate package.json file
   * @param config Server configuration
   * @returns ServerFile for package.json
   */
  private generatePackageJson(config: DirectServerConfig): ServerFile {
    const isTypescript = true; // This is the TypeScript generator
    
    // Prepare dependencies
    const dependencies = {
      'express': '^4.18.2',
      'dotenv': '^16.3.1',
      'cors': '^2.8.5',
      'typescript': '^5.0.4',
      'ts-node': '^10.9.1',
      '@types/express': '^4.17.17',
      '@types/cors': '^2.8.13'
    };
    
    // Format dependencies as string
    const depsString = Object.entries(dependencies)
      .map(([name, version]) => `"${name}": "${version}"`)
      .join(',\n    ');
    
    const context = {
      packageName: config.name.toLowerCase().replace(/\s+/g, '-'),
      description: config.description || 'MCP Server generated by MCP Server Generator',
      mainFile: 'dist/index.js',
      moduleType: 'commonjs',
      startScript: 'node dist/index.js',
      buildScript: 'tsc',
      devScript: 'ts-node src/index.ts',
      dependencies: depsString,
      config
    };
    
    return {
      name: 'package.json',
      path: '/',
      content: this.templateManager.renderTemplate('packageJson', context),
      type: 'config',
      language: 'json'
    };
  }
  
  /**
   * Generate tsconfig.json file
   * @returns ServerFile for tsconfig.json
   */
  private generateTsConfig(): ServerFile {
    return {
      name: 'tsconfig.json',
      path: '/',
      content: this.templateManager.getTemplate('tsConfig'),
      type: 'config',
      language: 'json'
    };
  }
  
  /**
   * Generate index.ts file
   * @param config Server configuration
   * @returns ServerFile for index.ts
   */
  private generateIndexFile(config: DirectServerConfig): ServerFile {
    const { authentication, endpoints } = config;
    
    // Prepare resource and tool lists for server info
    const resourcesList = endpoints
      .filter(e => e.mcpType === 'resource')
      .map(e => `'${e.path}'`)
      .join(', ');
      
    const toolsList = endpoints
      .filter(e => e.mcpType === 'tool')
      .map(e => `'${e.path}'`)
      .join(', ');
    
    // Auth import and middleware code
    const authImport = authentication.type !== 'None' 
      ? "import { authenticate } from './middleware/auth';" 
      : '';
      
    const authMiddleware = authentication.type !== 'None'
      ? "app.use('/mcp', authenticate);"
      : '';
    
    const context = {
      config,
      resourcesList,
      toolsList,
      authImport,
      authMiddleware
    };
    
    return {
      name: 'index.ts',
      path: '/src/',
      content: this.templateManager.renderTemplate('indexTs', context),
      type: 'code',
      language: 'typescript'
    };
  }
  
  /**
   * Generate resource routes file
   * @param config Server configuration
   * @returns ServerFile for resourceRoutes.ts
   */
  private generateResourceRoutesFile(config: DirectServerConfig): ServerFile {
    const { endpoints } = config;
    
    // Generate routes for each resource endpoint
    const resourceRoutes = endpoints
      .filter(endpoint => endpoint.mcpType === 'resource' && endpoint.selected !== false)
      .map(endpoint => {
        const params = endpoint.parameters
          .filter(param => param.required)
          .map(param => param.name)
          .join(', ');
        
        return `// ${endpoint.description || endpoint.path}
router.get('${endpoint.path}', async (req, res) => {
  try {
    // Validate query parameters if needed
    ${params ? `const { ${params} } = req.query;` : ''}
    
    // Return data in MCP-compliant format
    res.json({
      success: true,
      data: {
        id: '${endpoint.path}', // Resource identifier
        ${params ? `params: { ${params} },` : ''}
        // Add your resource data here
        content: [
          {
            type: 'text',
            text: 'Sample resource data for ${endpoint.path}'
          }
        ]
      }
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});`;
      }).join('\n\n');
    
    const context = {
      resourceRoutes,
      config
    };
    
    return {
      name: 'resourceRoutes.ts',
      path: '/src/routes/',
      content: this.templateManager.renderTemplate('resourceRoutes', context),
      type: 'code',
      language: 'typescript'
    };
  }
  
  /**
   * Generate tool routes file
   * @param config Server configuration
   * @returns ServerFile for toolRoutes.ts
   */
  private generateToolRoutesFile(config: DirectServerConfig): ServerFile {
    const { endpoints } = config;
    
    // Generate routes for each tool endpoint
    const toolRoutes = endpoints
      .filter(endpoint => endpoint.mcpType === 'tool' && endpoint.selected !== false)
      .map(endpoint => {
        const params = endpoint.parameters
          .filter(param => param.required)
          .map(param => param.name)
          .join(', ');
        
        return `// ${endpoint.description || endpoint.path}
router.post('${endpoint.path}', async (req, res) => {
  try {
    ${params ? `const { ${params} } = req.body;` : ''}
    
    // Extract request body
    const requestBody = req.body;
    
    // Return data in MCP-compliant format
    res.json({
      success: true,
      result: {
        id: '${endpoint.path}', // Tool identifier
        ${params ? `params: { ${params} },` : ''}
        content: [
          {
            type: 'text',
            text: 'Sample tool result for ${endpoint.path}'
          }
        ]
      }
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});`;
      }).join('\n\n');
    
    const context = {
      toolRoutes,
      config
    };
    
    return {
      name: 'toolRoutes.ts',
      path: '/src/routes/',
      content: this.templateManager.renderTemplate('toolRoutes', context),
      type: 'code',
      language: 'typescript'
    };
  }
  
  /**
   * Generate authentication middleware
   * @param config Server configuration
   * @returns ServerFile for auth.ts
   */
  private generateAuthMiddleware(config: DirectServerConfig): ServerFile {
    const { authentication } = config;
    
    const apiKeySource = authentication.location === 'header'
      ? `req.headers['${authentication.name || 'x-api-key'}']`
      : `req.query['${authentication.name || 'api_key'}']`;
    
    const context = {
      apiKeySource,
      config
    };
    
    return {
      name: 'auth.ts',
      path: '/src/middleware/',
      content: this.templateManager.renderTemplate('auth', context),
      type: 'code',
      language: 'typescript'
    };
  }
  
  /**
   * Get a list of features supported by this generator
   * @returns Array of supported feature strings
   */
  getSupportedFeatures(): string[] {
    return [
      ...super.getSupportedFeatures(),
      'typescript',
      'express',
      'cors',
      'dotenv'
    ];
  }
}
