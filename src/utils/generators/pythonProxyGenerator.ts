import { GenerationResult, ServerFile } from '@/types';
import { ExtendedServerConfig, ProxyServerConfig } from '@/types/serverConfig';
import { BaseGenerator } from './baseGenerator';
import { TemplateManager } from './templateManager';

/**
 * Generator for Python/FastAPI proxy servers
 * Implements MCP servers that proxy to existing APIs using the MCP Python library
 */
export class PythonProxyGenerator extends BaseGenerator {
  private templateManager: TemplateManager;
  
  constructor() {
    super();
    this.templateManager = new TemplateManager('python');
  }
  
  /**
   * Generate proxy server files for Python with MCP library
   * @param config Server configuration with proxy properties
   * @returns Generation result
   */
  generateServer(config: ExtendedServerConfig): GenerationResult {
    if (config.mode !== 'proxy') {
      throw new Error('PythonProxyGenerator only supports proxy mode. Use PythonGenerator for direct mode.');
    }
    
    const proxyConfig = config as ProxyServerConfig;
    
    try {
      const serverFiles: ServerFile[] = [];
      
      // Add standard files
      serverFiles.push(this.generateRequirementsTxt(proxyConfig));
      serverFiles.push(this.generateReadme(proxyConfig));
      serverFiles.push(this.generateEnvFile(proxyConfig));
      
      // Add source files
      serverFiles.push(this.generateMainFile(proxyConfig));
      serverFiles.push(this.generateProxyServiceFile(proxyConfig));
      
      // Create module init files
      serverFiles.push(this.generateInitFile('/services/'));
      
      return {
        success: true,
        files: serverFiles
      };
    } catch (error) {
      console.error('Error generating Python proxy server:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error generating Python proxy server'
      };
    }
  }
  
  /**
   * Generate requirements.txt file with MCP library
   * @param config Server configuration
   * @returns ServerFile for requirements.txt
   */
  private generateRequirementsTxt(config: ProxyServerConfig): ServerFile {
    // Define additional requirements based on configuration
    const additionalLines = [
      'mcp-server==0.1.0',  // MCP Python library
      ...(config.cacheEnabled ? ['cachetools==5.3.1'] : []),
    ];
    
    const additionalRequirements = additionalLines.join('\n');
    
    const context = {
      additionalRequirements,
      config
    };
    
    return {
      name: 'requirements.txt',
      path: '/',
      content: this.templateManager.renderTemplate('requirements', context),
      type: 'config',
      language: 'plaintext'
    };
  }
  
  /**
   * Generate main.py file with MCP Python implementation
   * @param config Server configuration
   * @returns ServerFile for main.py
   */
  private generateMainFile(config: ProxyServerConfig): ServerFile {
    const { authentication, endpoints, cacheEnabled } = config;
    
    // Main Python file for MCP proxy server
    const content = `#!/usr/bin/env python3
import os
import json
import asyncio
from typing import Dict, Any, Optional, List, Union
from dotenv import load_dotenv
from mcp_server import Server, StdioTransport, HttpTransport
from mcp_server.schemas import (
    ListResourcesRequest, ListResourcesResponse,
    ReadResourceRequest, ReadResourceResponse,
    ListToolsRequest, ListToolsResponse,
    CallToolRequest, CallToolResponse,
    ErrorResponse, Error
)
${cacheEnabled ? 'from cachetools import TTLCache' : ''}

# Import proxy service
from services.proxy_service import proxy_request

load_dotenv()

# Get configuration
TARGET_API_URL = os.getenv("TARGET_API_URL")
if not TARGET_API_URL:
    raise ValueError("TARGET_API_URL environment variable is not set")

${authentication.type !== 'None' ? 'MCP_API_KEY = os.getenv("MCP_API_KEY", "default-key")' : ''}
${cacheEnabled ? '# Create cache with TTL of 5 minutes (300 seconds)\ncache = TTLCache(maxsize=1000, ttl=300)' : ''}

class MCPProxyServer:
    """MCP Proxy Server using the official MCP library"""
    
    def __init__(self):
        # Initialize the MCP server
        self.server = Server(
            name="${config.name}",
            version="1.0.0",
            description="${config.description || 'MCP Proxy Server generated by MCP Server Generator'}"
        )
        
        # Setup request handlers
        self.setup_handlers()
    
    def setup_handlers(self):
        """Setup all MCP request handlers"""
        
        @self.server.request_handler(ListResourcesRequest)
        async def list_resources(request):
            """List available resources"""
            resources = [
                {
                    "uri": path,
                    "name": desc or path,
                    "description": desc or "Resource endpoint"
                }
                for path, desc in [
                    ${endpoints
                      .filter(e => e.mcpType === 'resource' && e.selected !== false)
                      .map(e => `("${e.path}", "${e.description || ''}")`)
                      .join(',\n                    ')}
                ]
            ]
            
            return ListResourcesResponse(resources=resources)
        
        @self.server.request_handler(ReadResourceRequest)
        async def read_resource(request):
            """Read a specific resource"""
            try:
                # Extract resource URI and parameters
                resource_uri = request.uri
                parts = resource_uri.split('?')
                path = parts[0]
                
                # Handle parameters if present
                params = {}
                if len(parts) > 1:
                    query_string = parts[1]
                    params = {k: v for k, v in [p.split('=') for p in query_string.split('&') if '=' in p]}
                
                ${authentication.type !== 'None' ? `
                # Validate authentication if required
                if not self._authenticate(request.headers):
                    return ErrorResponse(
                        error=Error(code="unauthorized", message="Invalid API key")
                    )
                ` : ''}
                
                # Make the request to the target API
                response_data = await proxy_request(
                    path.lstrip('/'),  # Remove leading slash if present
                    "GET",
                    params
                )
                
                # Return in MCP format
                return ReadResourceResponse(
                    contents=[
                        {
                            "uri": resource_uri,
                            "mimeType": "application/json",
                            "text": json.dumps(response_data, indent=2)
                        }
                    ]
                )
            except Exception as e:
                return ErrorResponse(
                    error=Error(code="internal_error", message=f"Proxy error: {str(e)}")
                )
        
        @self.server.request_handler(ListToolsRequest)
        async def list_tools(request):
            """List available tools"""
            tools = []
            
            # Add tools from configuration
            ${endpoints
                .filter(e => e.mcpType === 'tool' && e.selected !== false)
                .map(e => {
                  const paramProperties = e.parameters
                    .filter(p => p.required)
                    .map(p => `"${p.name}": { 
                        "type": "${p.type === 'number' ? 'number' : p.type === 'boolean' ? 'boolean' : 'string'}",
                        "description": "${p.description || p.name}" 
                      }`);
                    
                  return `tools.append({
                "name": "${e.path}",
                "description": "${e.description || 'Tool endpoint'}",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        ${paramProperties.join(',\n                        ')}
                    },
                    "required": [${e.parameters.filter(p => p.required).map(p => `"${p.name}"`).join(', ')}]
                }
            })`}).join('\n            ')}
            
            return ListToolsResponse(tools=tools)
        
        @self.server.request_handler(CallToolRequest)
        async def call_tool(request):
            """Execute a tool"""
            try:
                # Find the endpoint that matches the requested tool
                tool_name = request.name
                
                ${authentication.type !== 'None' ? `
                # Validate authentication if required
                if not self._authenticate(request.headers):
                    return ErrorResponse(
                        error=Error(code="unauthorized", message="Invalid API key")
                    )
                ` : ''}
                
                # Get the method for this tool
                tool_endpoint = None
                for endpoint in [
                    ${endpoints
                      .filter(e => e.mcpType === 'tool' && e.selected !== false)
                      .map(e => `{"path": "${e.path}", "method": "${e.method}"}`)
                      .join(',\n                    ')}
                ]:
                    if endpoint["path"] == tool_name:
                        tool_endpoint = endpoint
                        break
                
                if not tool_endpoint:
                    return ErrorResponse(
                        error=Error(code="not_found", message=f"Tool {tool_name} not found")
                    )
                
                # Make the request to the target API
                response_data = await proxy_request(
                    tool_name.lstrip('/'),  # Remove leading slash if present
                    tool_endpoint["method"],
                    None,
                    request.arguments
                )
                
                # Return in MCP format
                return CallToolResponse(
                    content=[
                        {
                            "type": "text",
                            "text": json.dumps(response_data, indent=2)
                        }
                    ]
                )
            except Exception as e:
                return ErrorResponse(
                    error=Error(code="internal_error", message=f"Proxy error: {str(e)}")
                )
        
        ${authentication.type !== 'None' ? `
        def _authenticate(self, headers):
            """Validate the API key"""
            api_key = headers.get("${authentication.name || 'x-api-key'}")
            return api_key == MCP_API_KEY
        ` : ''}
    
    async def run(self):
        """Run the MCP server"""
        # Choose transport based on environment
        use_stdio = os.getenv("USE_STDIO", "false").lower() == "true"
        port = int(os.getenv("PORT", "3000"))
        
        if use_stdio:
            # Use stdio transport for LLM integration
            transport = StdioTransport()
            print("Starting MCP server with stdio transport...", file=sys.stderr)
        else:
            # Use HTTP transport for direct usage
            transport = HttpTransport(port=port)
            print(f"Starting MCP server on http://localhost:{port}...", file=sys.stderr)
        
        print(f"Proxying requests to {TARGET_API_URL}", file=sys.stderr)
        
        await self.server.serve(transport)

if __name__ == "__main__":
    import sys
    
    # Create and run the server
    server = MCPProxyServer()
    
    if sys.platform == 'win32':
        # Windows-specific event loop policy
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    asyncio.run(server.run())`;

    return {
      name: 'main.py',
      path: '/',
      content,
      type: 'code',
      language: 'python'
    };
  }
  
  /**
   * Generate proxy service file
   * @param config Server configuration
   * @returns ServerFile for proxy_service.py
   */
  private generateProxyServiceFile(config: ProxyServerConfig): ServerFile {
    const { cacheEnabled, rateLimitingEnabled } = config;
    
    const content = `import httpx
import os
import json
from typing import Dict, Any, Optional, List
${cacheEnabled ? 'from cachetools import TTLCache' : ''}
${rateLimitingEnabled ? 'import time\nfrom collections import defaultdict' : ''}

# Get the target API URL from environment
TARGET_API_URL = os.getenv("TARGET_API_URL")
TARGET_API_KEY = os.getenv("TARGET_API_KEY")

# Create HTTP client
client = httpx.AsyncClient(base_url=TARGET_API_URL, timeout=30.0)

${cacheEnabled ? `
# Create cache with TTL of 5 minutes (300 seconds)
cache = TTLCache(maxsize=1000, ttl=300)
` : ''}

${rateLimitingEnabled ? `
# Simple rate limiter
RATE_LIMIT_WINDOW = 60  # seconds
RATE_LIMIT_MAX_REQUESTS = 60  # requests per minute
request_counts = defaultdict(list)

def check_rate_limit(client_id: str = "default") -> bool:
    """Check if the rate limit has been exceeded"""
    current_time = time.time()
    
    # Remove timestamps outside the window
    request_counts[client_id] = [
        timestamp for timestamp in request_counts[client_id] 
        if timestamp > current_time - RATE_LIMIT_WINDOW
    ]
    
    # Check if rate limit exceeded
    if len(request_counts[client_id]) >= RATE_LIMIT_MAX_REQUESTS:
        return False
    
    # Record this request
    request_counts[client_id].append(current_time)
    return True
` : ''}

def generate_cache_key(path: str, params: Dict[str, Any]) -> str:
    """Generate a cache key based on the path and parameters"""
    return f"{path}-{json.dumps(params, sort_keys=True)}"

async def proxy_request(
    path: str,
    method: str = "GET",
    params: Optional[Dict[str, Any]] = None,
    data: Optional[Dict[str, Any]] = None
) -> Any:
    """Forward a request to the target API and return the response"""
    try:
        # Remove leading slash if present
        if path.startswith("/"):
            path = path[1:]
            
        # Full URL
        url = f"{path}"
        
        # Generate cache key for GET requests
        cache_key = None
        if method == "GET" and params:
            cache_key = generate_cache_key(url, params or {})
            
        ${cacheEnabled ? `
        # Check cache for GET requests
        if method == "GET" and cache_key and cache_key in cache:
            print(f"Cache hit for {url}")
            return cache[cache_key]
        ` : ''}
        
        ${rateLimitingEnabled ? `
        # Check rate limit
        if not check_rate_limit():
            raise Exception("Rate limit exceeded. Please try again later.")
        ` : ''}
        
        # Set headers
        headers = {}
        if TARGET_API_KEY:
            # You might need to adjust this based on the API's authentication method
            headers["X-API-Key"] = TARGET_API_KEY
            # Alternatively:
            # headers["Authorization"] = f"Bearer {TARGET_API_KEY}"
            
        # Make the request based on the method
        if method == "GET":
            response = await client.get(url, params=params, headers=headers)
        elif method == "POST":
            response = await client.post(url, json=data, headers=headers)
        elif method == "PUT":
            response = await client.put(url, json=data, headers=headers)
        elif method == "DELETE":
            response = await client.delete(url, params=params, headers=headers)
        else:
            raise ValueError(f"Unsupported method: {method}")
            
        # Check if the request was successful
        response.raise_for_status()
        
        # Parse the response
        response_data = response.json()
        
        ${cacheEnabled ? `
        # Cache the response for GET requests
        if method == "GET" and cache_key:
            cache[cache_key] = response_data
        ` : ''}
        
        return response_data
    except httpx.HTTPStatusError as e:
        # Handle HTTP errors (4xx, 5xx)
        error_detail = f"Target API responded with status {e.response.status_code}"
        try:
            error_body = e.response.json()
            if "message" in error_body:
                error_detail += f": {error_body['message']}"
        except Exception:
            pass
            
        raise Exception(error_detail)
    except httpx.RequestError as e:
        # Handle network/connection errors
        raise Exception(f"Error communicating with target API: {str(e)}")
    except Exception as e:
        # Handle all other errors
        raise Exception(f"Proxy error: {str(e)}")`;

    return {
      name: 'proxy_service.py',
      path: '/services/',
      content,
      type: 'code',
      language: 'python'
    };
  }
  
  /**
   * Generate __init__.py file for a module
   * @param path Module path
   * @returns ServerFile for __init__.py
   */
  private generateInitFile(path: string): ServerFile {
    return {
      name: '__init__.py',
      path,
      content: '',
      type: 'code',
      language: 'python'
    };
  }
  
  /**
   * Get a list of features supported by this generator
   * @returns Array of supported feature strings
   */
  getSupportedFeatures(): string[] {
    return [
      ...super.getSupportedFeatures(),
      'python',
      'mcp-server',
      'proxy-mode',
      'httpx',
      'asyncio'
    ];
  }
}
