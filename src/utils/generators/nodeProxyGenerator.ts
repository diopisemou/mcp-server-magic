import { GenerationResult, ServerFile } from '@/types';
import { ExtendedServerConfig, ProxyServerConfig } from '@/types/serverConfig';
import { BaseGenerator } from './baseGenerator';
import { TemplateManager } from './templateManager';

/**
 * Generator for TypeScript/Node.js proxy servers
 * Implements MCP servers that proxy to existing APIs using the MCP SDK
 */
export class NodeProxyGenerator extends BaseGenerator {
  private templateManager: TemplateManager;
  
  constructor() {
    super();
    this.templateManager = new TemplateManager('typescript');
  }
  
  /**
   * Generate proxy server files for TypeScript/Node.js with MCP SDK
   * @param config Server configuration with proxy properties
   * @returns Generation result
   */
  generateServer(config: ExtendedServerConfig): GenerationResult {
    if (config.mode !== 'proxy') {
      throw new Error('NodeProxyGenerator only supports proxy mode. Use NodeGenerator for direct mode.');
    }
    
    const proxyConfig = config as ProxyServerConfig;
    
    try {
      const serverFiles: ServerFile[] = [];
      
      // Add standard files
      serverFiles.push(this.generatePackageJson(proxyConfig));
      serverFiles.push(this.generateReadme(proxyConfig));
      serverFiles.push(this.generateEnvFile(proxyConfig));
      serverFiles.push(this.generateTsConfig());
      
      // Add source files
      serverFiles.push(this.generateIndexFile(proxyConfig));
      serverFiles.push(this.generateProxyServiceFile(proxyConfig));
      
      return {
        success: true,
        files: serverFiles
      };
    } catch (error) {
      console.error('Error generating Node.js proxy server:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error generating Node.js proxy server'
      };
    }
  }
  
  /**
   * Generate package.json file with MCP SDK
   * @param config Server configuration
   * @returns ServerFile for package.json
   */
  private generatePackageJson(config: ProxyServerConfig): ServerFile {
    // Prepare dependencies
    const dependencies = {
      '@modelcontextprotocol/sdk': '^0.1.0',
      'dotenv': '^16.3.1',
      'axios': '^1.6.0',
      'typescript': '^5.0.4',
      'ts-node': '^10.9.1',
      ...(config.cacheEnabled ? { 'node-cache': '^5.1.2' } : {})
    };
    
    // Format dependencies as string
    const depsString = Object.entries(dependencies)
      .map(([name, version]) => `"${name}": "${version}"`)
      .join(',\n    ');
    
    const context = {
      packageName: config.name.toLowerCase().replace(/\s+/g, '-'),
      description: config.description || 'MCP Proxy Server generated by MCP Server Generator',
      mainFile: 'dist/index.js',
      moduleType: 'module', // Use ES modules for MCP SDK compatibility
      startScript: 'node dist/index.js',
      buildScript: 'tsc',
      devScript: 'ts-node-esm src/index.ts',
      dependencies: depsString,
      config
    };
    
    return {
      name: 'package.json',
      path: '/',
      content: this.templateManager.renderTemplate('packageJson', context),
      type: 'config',
      language: 'json'
    };
  }
  
  /**
   * Generate tsconfig.json file for MCP SDK
   * @returns ServerFile for tsconfig.json
   */
  private generateTsConfig(): ServerFile {
    // For MCP SDK, we need to use ES modules
    const content = `{
  "compilerOptions": {
    "target": "es2020",
    "module": "es2020",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}`;

    return {
      name: 'tsconfig.json',
      path: '/',
      content,
      type: 'config',
      language: 'json'
    };
  }
  
  /**
   * Generate index.ts main file with MCP SDK implementation
   * @param config Server configuration
   * @returns ServerFile for index.ts
   */
  private generateIndexFile(config: ProxyServerConfig): ServerFile {
    const { authentication, endpoints, cacheEnabled } = config;
    
    // Generate the imports section including conditional imports
    let imports = `import dotenv from 'dotenv';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { HttpServerTransport } from '@modelcontextprotocol/sdk/server/http.js';
import {
  CallToolRequestSchema,
  ErrorCode,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ListToolsRequestSchema,
  McpError,
  ReadResourceRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';`;

    // Add cache import if enabled
    if (cacheEnabled) {
      imports += `\nimport NodeCache from 'node-cache';`;
    }
    
    imports += `\nimport axios from 'axios';`;
    
    // Prepare endpoints list for JSON stringification
    const toolEndpoints = JSON.stringify(endpoints.filter(e => e.mcpType === 'tool' && e.selected !== false));
    
    // Generate the main content
    const mainContent = `
dotenv.config();

// Check required environment variables
const TARGET_API_URL = process.env.TARGET_API_URL;
if (!TARGET_API_URL) {
  console.error('TARGET_API_URL not set in environment variables!');
  process.exit(1);
}

// Create proxy services
import { proxyService } from './services/proxyService.js';

/**
 * MCP Proxy Server Class
 */
class MCPProxyServer {
  private server: Server;
  private targetApiUrl: string;
  ${cacheEnabled ? 'private cache: NodeCache;' : ''}
  ${authentication.type !== 'None' ? 'private apiKey: string;' : ''}

  constructor() {
    // Initialize MCP server
    this.server = new Server(
      {
        name: '${config.name}',
        version: '1.0.0',
      },
      {
        capabilities: {
          resources: {},
          tools: {},
        },
      }
    );

    // Initialize server properties
    this.targetApiUrl = TARGET_API_URL;
    ${cacheEnabled ? 'this.cache = new NodeCache({ stdTTL: 300, checkperiod: 60 });' : ''}
    ${authentication.type !== 'None' ? "this.apiKey = process.env.MCP_API_KEY || 'default-key';" : ''}

    // Set up request handlers
    this.setupResourceHandlers();
    this.setupToolHandlers();
    
    // Error handling
    this.server.onerror = (error) => console.error('[MCP Error]', error);
    process.on('SIGINT', async () => {
      await this.server.close();
      process.exit(0);
    });
  }

  /**
   * Set up resource request handlers
   */
  private setupResourceHandlers() {
    // List available resources
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
      resources: [
        ${endpoints
          .filter(e => e.mcpType === 'resource' && e.selected !== false)
          .map(e => `{
            uri: '${e.path}',
            name: '${e.description || e.path}',
            description: '${e.description || 'Resource endpoint'}'
          }`).join(',\n        ')}
      ],
    }));

    // Resource templates for dynamic parameters
    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => ({
      resourceTemplates: [
        ${endpoints
          .filter(e => e.mcpType === 'resource' && e.selected !== false && e.parameters.some(p => p.required))
          .map(e => {
            const params = e.parameters.filter(p => p.required).map(p => p.name);
            return params.length > 0 ? `{
            uriTemplate: '${e.path.replace(/{([^}]+)}/g, '{$1}')}',
            name: '${e.description || e.path}',
            description: 'Dynamic resource with parameters: ${params.join(', ')}'
          }` : '';
          }).filter(t => t !== '').join(',\n        ')}
      ],
    }));

    // Read specific resources
    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      ${authentication.type !== 'None' ? `
      // Check authentication if required
      if (!this.authenticate(request.headers)) {
        throw new McpError(ErrorCode.Unauthorized, 'Invalid API key');
      }
      ` : ''}

      try {
        // Extract resource ID and parameters from URL
        const resourceUri = request.params.uri;
        const parts = resourceUri.split('?');
        const path = parts[0];
        
        // Handle parameters if present
        let params = {};
        if (parts.length > 1) {
          const queryString = parts[1];
          params = Object.fromEntries(new URLSearchParams(queryString));
        }
        
        // Make the request to the target API
        const response = await proxyService.proxyRequest(
          path.replace(/^\\//, ''), // Remove leading slash if present
          'GET',
          params
        );
        
        // Return in MCP format
        return {
          contents: [
            {
              uri: resourceUri,
              mimeType: 'application/json',
              text: JSON.stringify(response, null, 2),
            },
          ],
        };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
        throw new McpError(ErrorCode.InternalError, \`Proxy error: \${errorMsg}\`);
      }
    });
  }

  /**
   * Set up tool request handlers
   */
  private setupToolHandlers() {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        ${endpoints
          .filter(e => e.mcpType === 'tool' && e.selected !== false)
          .map(e => {
            const paramProperties = e.parameters
              .filter(p => p.required)
              .map(p => `"${p.name}": { 
                "type": "${p.type === 'number' ? 'number' : p.type === 'boolean' ? 'boolean' : 'string'}",
                "description": "${p.description || p.name}" 
              }`);
              
            return `{
            name: '${e.path}',
            description: '${e.description || 'Tool endpoint'}',
            inputSchema: {
              type: 'object',
              properties: {
                ${paramProperties.join(',\n                ')}
              },
              required: [${e.parameters.filter(p => p.required).map(p => `'${p.name}'`).join(', ')}]
            }
          }`}).join(',\n        ')}
      ],
    }));

    // Handle tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      ${authentication.type !== 'None' ? `
      // Check authentication if required
      if (!this.authenticate(request.headers)) {
        throw new McpError(ErrorCode.Unauthorized, 'Invalid API key');
      }
      ` : ''}

      try {
        // Find the endpoint that matches the requested tool
        const toolName = request.params.name;
        const endpoint = ${toolEndpoints}.find(e => e.path === toolName);
        
        if (!endpoint) {
          throw new McpError(ErrorCode.MethodNotFound, \`Tool \${toolName} not found\`);
        }
        
        // Make the request to the target API
        const response = await proxyService.proxyRequest(
          toolName.replace(/^\\//, ''), // Remove leading slash if present
          endpoint.method,
          null,
          request.params.arguments
        );
        
        // Return in MCP format
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(response, null, 2),
            },
          ],
        };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
        throw new McpError(ErrorCode.InternalError, \`Proxy error: \${errorMsg}\`);
      }
    });
  }

  ${authentication.type !== 'None' ? `
  /**
   * Authenticate the request
   */
  private authenticate(headers: Record<string, string>): boolean {
    // Get the API key from headers
    const apiKey = headers['${authentication.name || 'x-api-key'}'];
    
    // Compare with stored API key
    return apiKey === this.apiKey;
  }
  ` : ''}

  /**
   * Start the MCP server
   */
  async run() {
    // Choose transport (HTTP for direct usage, stdio for LLM integration)
    const port = parseInt(process.env.PORT || '3000');
    const transport = process.env.USE_STDIO === 'true' 
      ? new StdioServerTransport() 
      : new HttpServerTransport({ port });
    
    await this.server.connect(transport);
    
    console.log('MCP Proxy Server running');
    console.log(\`Proxying requests to \${this.targetApiUrl}\`);
    
    if (transport instanceof HttpServerTransport) {
      console.log(\`Server available at http://localhost:\${port}\`);
    } else {
      console.log('Running in stdio mode for LLM integration');
    }
  }
}

// Create and run the server
const server = new MCPProxyServer();
server.run().catch(console.error);`;

    return {
      name: 'index.ts',
      path: '/src/',
      content: imports + mainContent,
      type: 'code',
      language: 'typescript'
    };
  }
  
  /**
   * Generate proxy service file
   * @param config Server configuration
   * @returns ServerFile for proxyService.ts
   */
  private generateProxyServiceFile(config: ProxyServerConfig): ServerFile {
    const { cacheEnabled, rateLimitingEnabled } = config;
    
    let imports = `import axios, { AxiosRequestConfig } from 'axios';`;
    
    if (cacheEnabled) {
      imports += `\nimport NodeCache from 'node-cache';`;
    }
    
    // Generate main content
    let content = `
${imports}

// Create axios instance for API requests
const apiClient = axios.create({
  baseURL: process.env.TARGET_API_URL,
  timeout: 10000,
});

${cacheEnabled ? `
// Cache setup (TTL: 5 minutes)
const cache = new NodeCache({ stdTTL: 300, checkperiod: 60 });
` : ''}

// Add authentication to target API if needed
apiClient.interceptors.request.use((config) => {
  // Example: Add API key to header
  const targetApiKey = process.env.TARGET_API_KEY;
  if (targetApiKey) {
    config.headers['X-API-Key'] = targetApiKey;
    // Alternatively, you might need:
    // config.headers['Authorization'] = \`Bearer \${targetApiKey}\`;
  }
  return config;
});

/**
 * Proxy service for making requests to the target API
 */
export const proxyService = {
  /**
   * Generate a cache key based on the request
   */
  generateCacheKey(path: string, params: any): string {
    return \`\${path}-\${JSON.stringify(params)}\`;
  },

  /**
   * Forward a request to the target API and process the response
   */
  async proxyRequest(
    path: string,
    method: string = 'GET',
    params: any = {},
    body: any = null
  ): Promise<any> {
    try {
      const cacheKey = this.generateCacheKey(path, params);
      
      ${cacheEnabled ? `
      // Check cache for GET requests
      if (method === 'GET' && cache.has(cacheKey)) {
        console.log(\`Cache hit for \${path}\`);
        return cache.get(cacheKey);
      }
      ` : ''}

      // Set up request configuration
      const config: AxiosRequestConfig = {
        method,
        url: path,
        params: method === 'GET' ? params : undefined,
        data: method !== 'GET' ? body : undefined,
      };

      // Make the request to the target API
      const response = await apiClient(config);
      
      ${cacheEnabled ? `
      // Cache the response for GET requests
      if (method === 'GET') {
        cache.set(cacheKey, response.data);
      }
      ` : ''}

      return response.data;
    } catch (error: any) {
      console.error(\`Error proxying request to \${path}:\`, error.message);
      
      if (error.response) {
        // The request was made and the server responded with a status code
        // that falls out of the range of 2xx
        throw new Error(\`Target API responded with status \${error.response.status}: \${
          error.response.data?.message || error.response.statusText
        }\`);
      } else if (error.request) {
        // The request was made but no response was received
        throw new Error('Target API did not respond');
      } else {
        // Something happened in setting up the request
        throw new Error(error.message);
      }
    }
  }${rateLimitingEnabled ? `,

  // Simple rate limiter
  requestTimestamps: {} as Record<string, number[]>,
  RATE_LIMIT_WINDOW: 60 * 1000, // 1 minute in milliseconds
  RATE_LIMIT_MAX_REQUESTS: 60, // 60 requests per minute

  /**
   * Check if the request is within rate limits
   */
  rateLimiter(clientId: string = 'default'): boolean {
    const now = Date.now();
    
    // Initialize or clean up old timestamps
    if (!this.requestTimestamps[clientId]) {
      this.requestTimestamps[clientId] = [];
    }
    
    // Remove timestamps outside the current window
    this.requestTimestamps[clientId] = this.requestTimestamps[clientId].filter(
      timestamp => timestamp > now - this.RATE_LIMIT_WINDOW
    );
    
    // Check rate limit
    if (this.requestTimestamps[clientId].length >= this.RATE_LIMIT_MAX_REQUESTS) {
      return false; // Rate limit exceeded
    }
    
    // Record this request
    this.requestTimestamps[clientId].push(now);
    return true; // Request allowed
  }` : ''}
};`;

    return {
      name: 'proxyService.ts',
      path: '/src/services/',
      content,
      type: 'code',
      language: 'typescript'
    };
  }
  
  /**
   * Get a list of features supported by this generator
   * @returns Array of supported feature strings
   */
  getSupportedFeatures(): string[] {
    return [
      ...super.getSupportedFeatures(),
      'typescript',
      'mcp-sdk',
      'proxy-mode',
      'axios',
      'dotenv'
    ];
  }
}
